# 初步模板



[TOC]





## 一、常用头文件、STL及string函数

### 1.String

```c++
string的比较：
bool operator==(const string &s1,const string &s2)const;//比较两个字符串是否相等
运算符">","<",">=","<=","!="均被重载用于字符串的比较；
int compare(const string &s) const;//比较当前字符串和s的大小
int compare(int pos, int n,const string &s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小
int compare(int pos, int n,const string &s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小
int compare(const char *s) const;
int compare(int pos, int n,const char *s) const;
int compare(int pos, int n,const char *s, int pos2) const;
compare函数在>时返回1，<时返回-1，==时返回0  
string的子串：
string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串

string的交换：
void swap(string &s2);    //交换当前字符串与s2的值

string类的插入函数：
string &insert(int p0, const char *s);
string &insert(int p0, const char *s, int n);
string &insert(int p0,const string &s);
string &insert(int p0,const string &s, int pos, int n);
//前4个函数在p0位置插入字符串s中pos开始的前n个字符
string &insert(int p0, int n, char c);//此函数在p0处插入n个字符c
iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置
void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符
void insert(iterator it, int n, char c);//在it处插入n个字符c

string类的删除函数
iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置
iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置
string &erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串

string类的迭代器处理：
string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。
用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：
const_iterator begin()const;
iterator begin();                //返回string的起始位置
const_iterator end()const;
iterator end();                    //返回string的最后一个字符后面的位置
const_iterator rbegin()const;
iterator rbegin();                //返回string的最后一个字符的位置
const_iterator rend()const;
iterator rend();                    //返回string第一个字符位置的前面
rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现
```

### 2.头文件

```c++
//#include<bits/stdc++.h>

#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>

#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
#define inr register int 
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7

int main()
{
	
	return 0;
}
```



### 2.STL



```c++
bool cmp(vector int a,vector int b)//sort函数的vec用法 
{
	return a>b;
} 
//	for(int i=0;i<vec.size();i++)
//	{
//		printf("%d\n",vec[i]);
//	}
sort(vec.begin(),vec.end(),cmp)

//stl 模板函数
//1.queue 队列，先进先出
queue<type>q;
q.push(); //从末尾插入一个元素
q.pop();//弹出队首个元素
q.front();//返回队首元素
q.size();//返回队列中元素的个数
q.empty();//判断队列是否为空，一般取反处理
while(!q.empty){} 
q.back();//返回队列最后一个元素

//2.stack 栈，先进后出
stack<type>st; 
st.empty() //堆栈为空则返回真，一般取反处理 
st.pop() //移除栈顶元素
st.push() //在栈顶增加元素
st.size() //返回栈中元素数目
st.top() //返回栈顶元素

//3.vector 向量==动态数组，可以根据数据规模扩大/缩小空间
vector<type>vec;
vec.push_back(这里填要放的变量)//末尾插入
vec.empty();//检查是否为空
vec.clear();//清空该数组里的元素 
vec.size();//返回个数
vec[n];//第n个元素
for(vector<int>::iterater it=vec.begin();it!=vec.end();++it)  //迭代器遍历 
{
	cout<<*it<<" ";
}

//4.set 集合，不存在相同的元素
set<int>s//定义一个set容器 类型为int型
s.clear()//清除所有元素
s.count()//判断元素是否在集合中返回bool型,有返回1,无返回0
s.empty()//判断集合是否为空,取反处理 
s.begin()//返回指向第一个元素的迭代器
s.end() //返回指向最后一个元素之后的迭代器，不是最后一个元素
s.erase()//删除集合中的元素
s.find()//返回一个指向被查找到元素的迭代器，如果没找到则返回end()
s.insert()//集合中插入元素
s.size()//集合中元素的数目
s.swap()//交换两个集合

//5.map 字典，一个键对应一个值，按键排序
map<string,int>mapstring; map<int,string>mapint;
map<sring,char>mapstring; map<char,string>mapchar;
map<char,int>mapchar;     map<int,char>mapint;
map<char,vector<int>>;//这样也可以！！！！ 
maplive.insert(pair<int,string>(102,"aclive"));//插入 
map[键]=n; //最常用的插入方法
m.erase()//删除一个元素
m.size()//回map中元素的个数
m.clear()//删除所有元素

//6.优先队列
//升序队列，小顶堆
priority_queue <int,vector<int>,greater<int> > q;
//降序队列，大顶堆
priority_queue <int,vector<int>,less<int> >q;

//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
//使用pair：先比较第一个，再比较第二个
//使用自定义结构
//方法1
struct tmp1 //运算符重载<
{
    int x;
    tmp1(int a) {x = a;}
    bool operator<(const tmp1& a) const
    {
        return x < a.x; //大顶堆
    }
};

//方法2
struct tmp2 //重写仿函数
{
    bool operator() (tmp1 a, tmp1 b)
    {
        return a.x < b.x; //大顶堆
    }
};

priority_queue<tmp1, vector<tmp1>, tmp2> f;


```



## 二、奇怪的方法

### 1.二分查找

```c++
#include<bits/stdc++.h>
using namespace std;
int gcd(int x,int y)
{
	return y == 0?x:gcd(y,x%y);
}
int lcm(int z,int w)
{
	return z/gcd(z,w)*w;
}
int findn(int a,int b,int c,int p)//容斥定理  
{									//返回在小于p的区间内abc三数倍数的个数 
		int ab = lcm(a,b);
		int ac = lcm(a,c);
		int bc = lcm(b,c);
		int abc = lcm(ab,c);
		int sa = p/a;
		int sb = p/b;
		int sc = p/c;
		int sab = p/ab;
		int sac = p/ac;
		int sbc = p/bc;
		int sabc = p/abc; 
		int s = sa + sb + sc - sab - sac - sbc + sabc;  //容斥的体现：全部减交集 
		return s;
}
int main()
{
	int n1,a1,b1,c1;
	while(scanf("%d%d%d%d",&n1,&a1,&b1,&c1)!=EOF)
	{
		int m;
		int l = 1;
		int r = 2147483647;
		while(l<r) //二分查找 
		{
			m = l + (r-l)/2;
			int v = findn(a1,b1,c1,m);
			if(v<n1)
				l = m+1; //向下折中，下进位 
			else
				r = m;			 
			/* 
			if (v>n1)
				r = m-1;	
			else if(v<n1)
				l = m+1;
			else 
				break;
			*/
//			printf("%d---%d--%d\n",m,l,r);
		}
		printf("%d\n",l);	
	}
	return 0;
} 
```



### 2.快读模板

```c++
#include<bits/stdc++.h>
using namespace std;
//快读模板（int） (grtchar)
/*//模板1 
int read()
{
	char ch=0;
	int res=0,flag=1;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')	flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		res=res*10+ch-'0';
		ch=getchar();
	}
	return flag*res; 
}
*/
//模板2 
int scan()
{
	int res = 0,ch,flag = 0;

    if((ch = getchar()) == '-')
		flag = 1;
	else if(ch>='0'&&ch<='9')
		res = ch-'0';
	while((ch = getchar())>='0'&&ch<='9')
		res = res * 10 + ch - '0'; 
	return flag ? -res : res ; 
} 

//快出模板（int）（putchar） （递归） 

void out(int a)
{
	if(a<0)
	{
		putchar('-');
		a*=-1;
	}
	if(a>9)
		out(a/10);
	putchar(a%10+'0');
}
int a[2500007];
int main()
{
	int n;
	while(scanf("%d",&n)!=EOF)
	{
		getchar();
		for(int i = 1;i<=n;++i)
		 	a[i] = scan();
		sort(a+1,a+n+1);
		for(int i = 1;i<n;++i)
		{
			out(a[i]);
			putchar(' ');
		}
		out(a[n]);
		putchar('\n'); 
	}
	return 0;
}
```



### 3.擂台法求众数

```c++
int n;
int js = 0;
int sta = -1;
int num[4500007]；
    
int found() //擂台法求众数 （仅仅适用于众数大于n/2的情况） 
{
	for(int i = 1;i<=n;++i)
	{
		num[i] = scan(); 
		if(sta == -1) //擂台上没人就上去呗 
		{
			sta = num[i];  
			++js;
		}
		else if(sta == num[i]) //如果擂台上的数就是这个，计数加一 
		{
			++js;
		}
		else
		{
			--js;	//如果不是这个数，计数减一 
			if(!js) //一直到计数为零为止 
			{
				sta = -1; //擂台清空，等待下一个数。 
			}			
		}
	}
	return sta;//最后的返回值可能是众数（>n/2）或最后的几个数,或零（众数少于n/2） 
}
```

### 4.离散化

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
const int maxn = 200007;

int n,m,len;
int a[maxn];
int b[maxn];
int c[maxn];
int d[maxn*3];
int num[maxn];

void discrete()// 离散化 
{
	len = 0;
	for(int i = 1;i<=n;i++){
		d[++len] = a[i];
	}
	for(int i = 1;i<=m;i++){
		d[++len] = b[i];
		d[++len] = c[i];
	}							//a,b,c全加进去，才能保证出现的所有语言全部能够离散化 
	sort(d+1,d+len+1);
	len = unique(d+1,d+len+1) - (d+1); //返回全部语言的种数（num和d的数组长度） 
}

int query(int x) //返回离散化前后的对应关系 
{
	return lower_bound(d+1,d+len+1,x) - d;
}

int main()
{
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
		scanf("%d",&a[i]);
	scanf("%d",&m);
	for(int i = 1;i<=m;i++)
		scanf("%d",&b[i]);
	for(int i = 1;i<=m;i++)
		scanf("%d",&c[i]);
	discrete();
	for(int i = 1;i<=n;i++){
		num[query(a[i])]++;
	}
	int ans = 1;//比大小，记录最大值 
	int fl,sl;
	int mxfl = 0,mxsl = 0;
	for(int i = 1;i<=m;i++){
		fl = num[query(b[i])];
		sl = num[query(c[i])];
		if(fl > mxfl || (fl == mxfl && sl > mxsl)){
			mxfl = fl;
			mxsl = sl;
			ans = i;
		}
	}
	printf("%d\n",ans);
	return 0;
}

```



### 5.流输入

```c++
string st;
int n,sum;
int main()
{
	while(getline(cin,st)){
		stringstream io(st);
		while(io>>n){
            sum += n;
		}
        cout<<sum<<endl;
	}
	return 0;
}
```



### 6、递推与递归

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll dp[100000 + 11];

ll n1,n2,n3,n4;

ll fun(ll n)
{
	if(n == 1)
		return 1;
	if(n == 2)
		return 2;
	if(n == 3)
		return 4;
	else{
		n1 = 1;
		n2 = 2;
		n3 = 4;
		for(int i = 1;i<=n-3;i++){
			n4 = n1+n2+n3;
			n4 %= 1000000007;
			n1 = n2;
			n2 = n3;
			n3 = n4;
		}
		return n4;
	}
}
int main()
{
    ll a;
    while(scanf("%lld",&a)!=EOF)
        printf("%lld\n",fun(a));
    return 0;
}

```



### 7.二进制技巧（位运算和bitset）

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7
/* 
int ksm(int x,int y)
{
	int ans = 1;
	while (y)
	{
		if (y&1) ans = ans * x;
		y >>= 1;
		x *= x;
	}
	return ans;
} 

int main()
{
	ios;
	int n;
	bitset<32>bt;//按位存储 
	string st;
	while(cin>>n&&n){
		bt = n;
		st = bt.to_string();//转成字符串 
		for (int i = 31; i >= 0; i--){
			if (st[i] =='1'){
				cout<< ksm(2,31-i) << endl;
				break;
			}
		}
	}
	return 0;
}
*/ 

int main()//二进制常见技巧 
{
	ios;
	int n;
	while(cin>>n&&n){
		for (int i = 0; i<= 31; i++){
			if (n & 1<<i){
				cout<<(1<<i)<<endl;
				break;
			}
		}
	}
	return 0;
}
```

### 8.二维差分/前缀和

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
const int maxn = 10000007;

int a[maxn];
int n,m;

void add(int x,int y,int val)//降维打击：一维数组存二维图 
{
	if(x>n||y>m) return ;
	a[(x-1) * m + y] += val;//类似于染色？？ 
}

int query(int x,int y) //防0 ，边界判定 
{
	if(x == 0 || y == 0)
		return 0;
	return a[(x-1) * m + y];
}

void qsum() //求二维前缀和 
{
	for(int i = 1;i<=n;i++){
		for(int j = 1;j<=m;j++){
			a[(i-1)*m+j] += query(i,j-1) + query(i-1,j) - query(i-1,j-1);
		}
	}
}

int main()
{
	while(~scanf("%d%d",&n,&m)){
		memset(a,0,sizeof(a));
		int x1,x2,y1,y2;
		int p,q;
		scanf("%d",&p);
		while(p--){
			scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
			add(x1,y1,1);				//打上差分标记，注意距离原点最近和最远的点（的再外一点）为相应的增值 
			add(x2+1,y2+1,1);				//另外两个顶点为相应增值的负值 
			add(x1,y2+1,-1);				//这样，利用二维前缀和计算方法的特殊性，可以先打上标记，最后只求一遍前缀和即可标记所有覆盖区域 
			add(x2+1,y1,-1);
		}
		qsum();	// 第一遍求前缀和，得到被覆盖点的信息（但由于有的区域会被多重覆盖，会多出一些信息) 
		for(int i = 1;i<=n;i++){
			for(int j = 1;j<=m;j++){
				if(a[(i-1)*m+j]){
				a[(i-1)*m+j] = 1;	//染色只需要0与1的区别，也方便后面染色面积的计算		
				}
			}
		}
		qsum();			// 这里就得到了纯粹的监控面积 
		scanf("%d",&q);
		while(q--){
			scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
			int sump = query(x2,y2) - query(x1-1,y2) - query(x2,y1-1) + query(x1-1,y1-1);
			sump == ((x2-x1+1) * (y2-y1+1)) ? printf("YES\n") : printf("NO\n"); 
		}	
	}
	return 0;
}
```

### 9.大数

#### （1）__int128

```c++
#include <bits/stdc++.h>
using namespace std;
inline __int128 read()
{
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void write(__int128 x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
}

int main()
{
    __int128 a = read();
    __int128 b = read();
    write(a + b);
    return 0;
}）
```

#### （2）Java

##### 大数操作

正常情况下一个整数最多只能放在long类型之中，但是如果现在有如下的一个数字：
    1111111111111111111111111111111111111111111111111
根本就是无法保存的，所以为了解决这样的问题，在java中引入了两个大数的操作类：
    操作整型：BigInteger
    操作小数：BigDecimal
当然了，这些大数都会以**字符串**的形式传入。

```Java
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
    public static void main(String args[]){
        Scanner cin = new Scanner (System.in);
        int T = cin.nextInt();
        while(T > 0){
            BigInteger ans = BigInteger.ZERO;
            BigInteger num = cin.nextBigInteger();
            while(num.compareTo(BigInteger.ZERO) != 0){
                ans = ans.add(num);
                num = cin.nextBigInteger();
            }
            System.out.println(ans);
            ans = BigInteger.ZERO;
            if(T != 1){
                System.out.println("");
            }
            T--;
        }
    }
}

/*
JAVA多组输入
import java.util.Scanner;
public class Main
{
	public static void main(String[] args) 
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
		    int a = in.nextInt();
			int b = in.nextInt();
			System.out.println((a + b));
		}	
	}
}

*/
```



##### BigInteger

​    如果在操作的时候一个整型数据已经超过了整数的最大类型长度long的话，则此数据就无法装入，所以，此时要使用BigInteger类进行操作。

![img](https://img-blog.csdn.net/20160823162406249)

​    BigInteger是在java.math包中。

代码示例：

```java
package ustc.lichunchun.bigdataapi;

import java.math.BigInteger;

public class BigIntegerDemo1 {
    public static void main(String[] args) {
        BigInteger bi1 = new BigInteger("123456789") ;	// 声明BigInteger对象
        BigInteger bi2 = new BigInteger("987654321") ;	// 声明BigInteger对象
        System.out.println("加法操作：" + bi2.add(bi1)) ;	// 加法操作
        System.out.println("减法操作：" + bi2.subtract(bi1)) ;	// 减法操作
        System.out.println("乘法操作：" + bi2.multiply(bi1)) ;	// 乘法操作
        System.out.println("除法操作：" + bi2.divide(bi1)) ;	// 除法操作
        System.out.println("最大数：" + bi2.max(bi1)) ;	 // 求出最大数
        System.out.println("最小数：" + bi2.min(bi1)) ;	 // 求出最小数
        BigInteger result[] = bi2.divideAndRemainder(bi1) ;	// 求出余数的除法操作
        System.out.println("商是：" + result[0] +
                "；余数是：" + result[1]) ;
    }
}

```

发现divide()方法本身只是把最终的商保存下来了，但是这样的两个数字相除的时候肯定是无法整除，肯定存在余数，所以我们在上面代码中还用到了divideAndRemainder()方法来获得结果和余数。

##### BigDecimal

​    使用此类可以完成大的小数操作，而且也可以使用此类进行精确的四舍五入，这一点在开发中经常使用。
​    对于不需要任何准确计算精度的程序可以直接使用float或double完成，但是如果需要精确计算结果，则必须使用BigDecimal类。

![img](https://img-blog.csdn.net/20160823162409327)

代码示例：

```java
package ustc.lichunchun.bigdataapi;

import java.math.BigDecimal;

public class BigDecimalDemo01 {

    public static void main(String[] args) {
        System.out.println("加法运算：" + MyMath.round(MyMath.add(10.345,3.333),1)) ;
        System.out.println("减法运算：" + MyMath.round(MyMath.sub(10.345,3.333),3)) ;
        System.out.println("乘法运算：" + MyMath.round(MyMath.mul(10.345,3.333),4)) ;
        System.out.println("除法运算：" + MyMath.div(10.345,3.333,3)) ;
    }
}
class MyMath{
    public static double add(double d1,double d2){		// 进行加法计算
        BigDecimal b1 = new BigDecimal(d1) ;
        BigDecimal b2 = new BigDecimal(d2) ;
        return b1.add(b2).doubleValue() ;
    }
    public static double sub(double d1,double d2){		// 进行减法计算
        BigDecimal b1 = new BigDecimal(d1) ;
        BigDecimal b2 = new BigDecimal(d2) ;
        return b1.subtract(b2).doubleValue() ;
    }
    public static double mul(double d1,double d2){		// 进行乘法计算
        BigDecimal b1 = new BigDecimal(d1) ;
        BigDecimal b2 = new BigDecimal(d2) ;
        return b1.multiply(b2).doubleValue() ;
    }
    public static double div(double d1,double d2,int len){		// 进行除法计算
        BigDecimal b1 = new BigDecimal(d1) ;
        BigDecimal b2 = new BigDecimal(d2) ;
        return b1.divide(b2,len,BigDecimal.ROUND_HALF_UP).doubleValue() ;
    }
    public static double round(double d,int len){	// 进行四舍五入
        BigDecimal b1 = new BigDecimal(d) ;
        BigDecimal b2 = new BigDecimal(1) ; // 技巧
        return b1.divide(b2,len,BigDecimal.ROUND_HALF_UP).doubleValue() ;
    }
};

```

 

## 三、数论

### 1、快速幂取模

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
ll ksm(ll x,ll y,ll mod)
{
	ll ans = 1;
	x = x % mod;
	while (y)
	{
		if (y&1) ans = ans * x % mod; //指数为奇就分一个底数出来单独乘 （至少最后y=1时会把值赋给ans） 
		y >>= 1;
		x *= x%mod;//自己平方一下 (累平方) 
	}
	return ans;
} 

```



### 2、gcd与lcm（欧几里得定理）

```c++
#include<bits/stdc++.h>
using namespace std;
int gcd(int a,int b)
{
	return b ==0?a:gcd(b,a%b);
}
long long lcm(int x,int y)
{
	long long res;
	res = x/gcd(x,y)*y;	
	return res;
}
```



### 3、拓展欧几里得定理

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;

//利用拓展欧几里得定理求解关于x，y的线性不定方程的最小正整数解
//参考文献 
// https://blog.csdn.net/m0_37579232/article/details/89810566
//https://blog.csdn.net/m0_37579232/article/details/81428065 
//https://fireworks99.github.io/2019/05/31/扩展欧几里得/ 
 
ll exgcd(ll a, ll b,ll & x, ll & y)  
{							//初始给定的x，y可以是任意值，在后来的递归运算中x，y
    int r = a;				//的值会不断改变直到变成可行的最小值 
    if(b != 0)
    {
        r = exgcd(b, a % b, y, x);
        y -= (a / b) * x;
    }
    else  x = 1, y = 0;
    return r;
}
int main()
{
	ll x,y,m,n,s;
	while(scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&s)!=EOF)
	{
		ll a1 = n-m;
		ll b1 = s;
		ll c1 = x-y;
		if (a1<0)
		{
			a1 *= -1;
			c1 *= -1; 
		}
		ll gc = exgcd(a1,b1,x,y);	//exgcd的返回值即gcd（a，b） 
		if (c1%gc != 0)	//判断给定的参数c符不符合定理要求即c = k*gcd（a，b）
		{						
			printf("%d\n",-1);		//否则无整数解
		}
		else
		{
			x *= c1/gc;	//x返回的为使ax+by=gcd(a,b)的最小解，现化为ax+by=c的解 
			ll b2 = b1/gc;		//b2为使x，y同为整数的x的最小变化单位 ，即b/gcd(a,b) 
			if(x>=0)
				x = x%b2;										
			else 
				x = (x%b2)+b2;	//若x为负，只需先去x mod b 得到最大的负整数解( >-b2 )  
			printf("%lld\n",x);	// 再加一个 b2即为最小正整数解 
		}	
	}
	return 0;
}
```



### 4、欧拉筛

```c++
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 30000007;

int prime(int num)			//判断素数 
{
	if ( num % 2 == 0 && num!=2)		//偶数就不说了 
		return 0;
	else
	{
		int sq = sqrt(num)+1;		//当这个数不是它平方根以内所有的数的倍数时，其必为素数 
		for (int j = 3;j<=sq;j++)
		{
			if ( num % j == 0)
				return 0;
		}
	}	
	return 1;
} 

int del[MAXN];		//用于标记合数 
int son[MAXN];		//用于存储该数的最小质因数 
vector<int>per;		//用于存储目前所知的所有素数 

void ols(int n)		//欧拉筛求最小质因数 
{
	for(int i = 2;i<=n;i++)
	{
		if(del[i] == 0) 	//素数就推进队列 
		{
			per.push_back(i);
			son[i] = i;
		}	
	
		for(int j = 0;j<=per.size();j++)	//遍历目前找出的所有的素数 
		{
			if(i*per[j] > n)	//越界就不用看了 
				break;
			del[i*per[j]] = 1;		//找出一个合数就标记一下 
			son[i*per[j]] = per[j];	//将那个合数的最小质因数记下来 
			if(i%per[j] == 0)	//保证是最小的质因数 
				break;
		}
	}
}

int le = 0;
int zys[MAXN];		//存质因数 

int main()
{
	int n;
	scanf("%d",&n);
	ols(n);
	int m = n;
	for(int i = m;m>1;m/=son[m])	//挨个除去…算了我不写了你自己看吧 
	{
		zys[++le] = son[m];
	}
	printf("%d=",n);
	for(int i = 1;i<=le;i++)
	{
		printf("%d",zys[i]);
		i != le ? printf("*") : printf("\n");
	}
	return 0;
}
```

#### 线性筛

```c++
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
const int MAXN = 1000002;

int cot;
int su[MAXN];
int del[MAXN];		//用于标记合数 
int son[MAXN];		//用于存储该数的最大质因数 
int per[MAXN];		//用于存储目前所知的所有素数 

void prime(int n) //简易素数筛(埃氏筛)（记录最大质因数） 
{
//	del[0] = 1;
//	del[1] = 1;
	cot = 0;
	for(int i = 2;i<=n;++i)
	{
		if(!del[i])//是素数就进队 
		{
			per[++cot] = i;
			son[i] = cot; //他最大的质因数就是它自己 
		
			for(int j = i<<1;j<n;j+=i)//遍历i的倍数 
			{
				del[j] = 1; //绝对是合数，标记 
				son[j] = cot;//这里记录的是它最后（大）质因数在peime数组里的位置 
			}//想直接记录最大质因数用记录i就可以 
		}	
	}
}

int main()
{
	int num;
	prime(MAXN);
	while(~scanf("%d",&num))
		printf("%d\n",son[num]);
	return 0;
}

```



### 5.快速幂求逆元

​		**modP情况下x的逆元：x^(P-2)**

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 

ll ksm(ll x,ll y,ll mod)
{
	ll ans = 1;
	x = x % mod;
	while (y>0)
	{
		if (y&1) ans = (ans * x)% mod; 
		y >>= 1;
		x = (x*x)%mod;
	}
	return ans;
} 

int main()
{
	ios;
	int T;
    ll x,y,p;
	cin>>T;
	while(T--){
		cin>>y>>p;
		if(p == 1){
			cout<<-1<<endl;
			continue ;
		}
		x = ksm(y,p-2,p);
		if((x*y)%p == 1){
			cout<<x%p<<endl;
		} 
		else{
			cout<<-1<<endl;
		}
	}
	return 0;
}
```



### 6.高斯消元

#### 高斯消元求阶异或方程组



```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>

#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi = acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 57;//1e5+7 
const ll mod = 1000000007;//1e9+7

ll read()
{
	ll res = 0, ch, flag = 0;

	if ((ch = getchar()) == '-')
		flag = 1;
	else if (ch >= '0' && ch <= '9')
		res = ch - '0';
	while ((ch = getchar()) >= '0' && ch <= '9')
		res = res * 10 + ch - '0';
	return flag ? -res : res;
}


ll Ksm(ll x, ll y)
{
	ll ans = 1;
	x = x % mod;
	while (y > 0)
	{
		if (y & 1) ans = (ans * x) % mod;
		y >>= 1;
		x = (x * x) % mod;
	}
	return ans;
}

//有equ个方程，var个变元。增广矩阵行数为equ,列数为var+1,分别为0到var
int n, equ, var;
int mat[maxn][maxn]; //增广矩阵
int x[maxn]; //解集
int free_x[maxn];//用来存储自由变元（多解枚举自由变元可以使用）
int free_num;//自由变元的个数

//返回值为-1表示无解，为0是唯一解，否则返回自由变元个数
int Gauss()
{
	int max_r, col, k;
	free_num = 0;
	for (k = 0, col = 0; k < equ && col < var; k++, col++)
	{
		max_r = k;
		for (int i = k + 1; i < equ; i++)
		{
			if (abs(mat[i][col]) > abs(mat[max_r][col]))
				max_r = i;
		}
		if (mat[max_r][col] == 0)
		{
			k--;
			free_x[free_num++] = col;//这个是自由变元
			continue;
		}
		if (max_r != k)
		{
			for (int j = col; j < var + 1; j++)
				swap(mat[k][j], mat[max_r][j]);
		}
		for (int i = k + 1; i < equ; i++)
		{
			if (mat[i][col] != 0)
			{
				for (int j = col; j < var + 1; j++)
					mat[i][j] ^= mat[k][j];
			}
		}
	}
	for (int i = k; i < equ; i++)//进入此循环的条件：本身矩阵行大于列 或者 因为出现自由变元后使得非自由变元数比行数小
		if (mat[i][col] != 0)//若等号右边是1则无解，因为等号左边已经消为0
			return -1;//无解
	if (k < var) return var - k;//自由变元个数
	//唯一解，回代
	for (int i = var - 1; i >= 0; i--)
	{
		x[i] = mat[i][var];
		for (int j = i + 1; j < var; j++)
			x[i] ^= (mat[i][j] && x[j]);
	}
	return 0;
}

int main()
{
	ios;
	int T;
	cin >> T;
	while (T--) {
		cin >> n;
		for (int i = 0; i < n; i++) {
			cin >> mat[i][n];
			mat[i][i] = 1;
		}
		for (int i = 0, tp; i <n; i++) {
			cin >> tp;
			mat[i][n] ^= tp;
		}
		int aa, bb;
		while (cin >> aa >> bb && (aa || bb)) {
			mat[bb - 1][aa - 1] = 1;
		}
		equ = n;
		var = n;
		int ans = Gauss();
		if (ans == -1) {
			cout << "Oh,it's impossible~!!" << endl;
		}
		else {
			ll ans = Ksm(2, free_num);
			cout << ans << endl;
		}
		memset(mat, 0, sizeof(mat));
	}
	return 0;
}


/*
//法Ⅱ：简单高斯消元求秩
int n;
int mat[maxn][maxn];

//现矩阵、m行、n列
int Rank(int A[][maxn], int m, int n) {//高斯消元求秩
	int i = 0, j = 0, k, r, u;
	while (i <= m && j <= n) {
		r = i;//处理第i个方程的第j个变量
		while (A[r][j] == 0 && r <= m) {//寻找在当前第j列的系数不为零的行
			r++;
		}
		if (A[r][j]) {
			swap(A[i], A[r]);//把该行换上去
			for (int u = i + 1; u <= m; u++) {//遍历下方行
				if (A[u][j]) {//如果在该列系数仍不为1，异或消元
					for (int k = i; k <= n; k++) {
						A[u][k] ^= A[i][k];
					}
				}
			}
			i++;
		}
		j++;//主要思想：类似于化上三角行列式的消元方法
	}
	return i;//当下方消不动（不用消了）的时候，剩下的行数就是秩数
}

int main()
{
	ios;
	int T;
	cin >> T;
	while (T--) {
		cin >> n;
		for (int i = 1; i <= n; i++) {
			cin >> mat[i][n+1];
			mat[i][i] = 1;
		}
		for (int i = 1, tp; i <=n; i++) {
			cin >> tp;
			mat[i][n+1] ^= tp;
		}
		int aa, bb;
		while (cin >> aa >> bb && (aa || bb)) {
			mat[bb][aa] = 1;
		}
		int rab = Rank(mat, n, n + 1);;
		int ra = Rank(mat, n, n);
		if (ra != rab) {
			cout << "Oh,it's impossible~!!" << endl;
		}
		else {
			ll ans = Ksm(2, n - rab);
			cout << ans << endl;
		}
		memset(mat, 0, sizeof(mat));
	}
	return 0;
}
*/ 
```



### 7.杨辉三角速推组合数

![image-20201030195636069](C:\Users\姬彬荃\AppData\Roaming\Typora\typora-user-images\image-20201030195636069.png)![image-20201030195851542](C:\Users\姬彬荃\AppData\Roaming\Typora\typora-user-images\image-20201030195851542.png)



```c++
#include <bits/stdc++.h>
#define ll long long 
using namespace std;

ll zhs[75][75];
       // m // n
void db()
{
	zhs[0][0] = 1;
	for(int i = 1;i<=62;i++){
		zhs[i][i] = 1;
		zhs[1][i] = i;
		zhs[0][i] = 1;
	}
	for(int i = 1;i<=62;i++){
		for(int j = 2;j<=i;j++){
			zhs[j][i] = (zhs[j][i-1] + zhs[j-1][i-1]);
		}
	}
}

int main()
{
	int t;
	db();
	scanf("%d",&t);
	while(t--){
		int m,n;
		scanf("%d%d",&n,&m);
		printf("%lld\n",zhs[m][n]);
	}
	return 0;
}
```



### 8.矩阵快速幂

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;
const ll mod = 1000000007;

struct mat{
	ll m[5][5];
};

int len = 3;
mat ml,mm,mr;

mat mul(mat a,mat b)
{
	mat res;
	for(int i = 1;i<=len;i++){
		for(int j = 1;j<=len;j++){
			res.m[i][j] = 0;
			for(int k = 1;k<=len;k++){
				res.m[i][j] += ( a.m[i][k] * b.m[k][j]);
				res.m[i][j] %= mod;
			}
		}
	}
	return res;
}

mat matksm(mat x,ll n)
{
	mat res;
	memset(res.m,0,sizeof(res.m));
	res.m[1][1] = res.m[2][2] = res.m[3][3] = 1;
	while(n){
		if(n&1){
			res = mul(res,x);
		}
		x = mul(x,x);
		n >>= 1;
	}
	return res;
}


int main()
{
	ll n;
	memset(ml.m,0,sizeof(ml.m));
	memset(mm.m,0,sizeof(mm.m));
	ml.m[1][1] = 4,ml.m[1][2] = 2,ml.m[1][3] = 1;
	mm.m[1][1] = mm.m[1][2] = 1;
	mm.m[2][1] = mm.m[2][3] = 1;
	mm.m[3][1] = 1;
	while(~scanf("%lld",&n)){
		if(n == 1){
			printf("%d\n",1);
			continue;
		} 
		if(n == 2){
			printf("%d\n",2);
			continue;
		} 
		if(n == 3){
			printf("%d\n",4);
			continue;
		} 
		mat tmp = matksm(mm,n-3);c++
		mr = mul(ml,tmp);
		ll ans = mr.m[1][1];
		printf("%lld\n",ans);
	}
	return 0;
}
```



## 四、图论

### 1、简单搜索

#### （1）深度优先搜索（DFS）

##### 		①普通

```c++
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 17;

int n,ans;
int mp[MAXN][MAXN];
int vis[MAXN][MAXN][2];//0-w 1-b //三维数组分别标记黑皇后和白皇后 

void init()
{
	ans = 0;
	memset(vis,0,sizeof(vis));
}

bool check(int d,int v,int s)
{
	bool pd = true;
	if(mp[d][v] == 0||vis[d][v][!s] == 1){
		return pd = false;
	}
	for(int i = 1;pd&&i<n;i++){
		if(vis[i][v][s] == 1){
			return pd = false;
		}
	}
	for(int i = 1;pd&&d-i>0&&v-i>0;i++){
		if(vis[d-i][v-i][s] == 1){
			return pd = false;
		}
	}
	for(int i = 1;pd&&d-i>0&&v+i<=n;i++){
		if(vis[d-i][v+i][s] == 1){
			return pd = false;
		}
	}
	return pd;
}

void dfs(int dep)
{
	if(dep == n+1){
		ans++;		//两边都能跑了才加一答案 
		return;
	}
	for(int i = 1;i<=n;i++){
		if(check(dep,i,0)){
			vis[dep][i][0] = 1;
			dfs(dep+1);
			vis[dep][i][0] = 0;
		}
	}
}

void ddfs(int dep)
{
	if(dep == n+1){
		dfs(1);			//先跑黑皇后，再跑白皇后 
		return;
	}
	for(int i = 1;i<=n;i++){
		if(check(dep,i,1)){
			vis[dep][i][1] = 1;
			ddfs(dep+1);
			vis[dep][i][1] = 0;
		}
	}
}

int main()
{
	init();
	scanf("%d",&n);
	for(int i = 1;i<=n;i++){
		for(int j = 1;j<=n;j++){
			scanf("%d",&mp[i][j]);
		}
	}
	ddfs(1);
	printf("%d\n",ans);
	return 0;
}
```



##### 	②字符串

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 35;

char ch;
int n,ma = 0;
string a[MAXN];
int pd[MAXN];

void dfs(string b,int le)
{
	ma = max(le,ma);
	for(int i = 0;i<n;i++)
	{
		if(pd[i]<2){
			int lea = a[i].length();
			int leb = b.length();
			int mi = min(lea,leb);
		
			for(int j = mi - 1;j>=1;j--){
				if(b.substr(leb - j,leb) == a[i].substr(0,j)) 
				{
					int cd = b.substr(leb-j,leb-1).length();
					pd[i]++;
					dfs(a[i],le+lea-cd);
					pd[i]--;
				}
			}
		}
	}
}

int main()
{
	scanf("%d",&n);
	for(int i = 0;i<n;i++){
		cin >> a[i];
	}
//	getchar();
//	scanf("%c",ch);
	cin >> ch;
	for(int i = 0;i<n;i++){
		if(a[i][0] == ch){
			memset(pd,0,sizeof(pd));
			pd[i]++;
			dfs(a[i],a[i].length());
		}
	}
	printf("%d\n",ma);
	return 0;
}
```



#### （2）广度优先搜索（BFS）

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>

using namespace std;

struct man
{
	int x;
	int y;
};

int w,h,mx,my,sum;
int vec[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
char wd[25][25];
int vis[25][25];
queue<man>q;

bool check(int x,int y)
{
	if( x<0 || y<0 || x>=8 || y>=8 || wd[x][y]=='#' || vis[x][y]==1 )
		return false;
	else
		return true;
}

void bfs(int x,int y)
{
	man zz;
	zz.x = x;
	zz.y = y;
	q.push(zz);
	while(!q.empty())
	{
		man fu = q.front();
		q.pop();
		if(vis[fu.x][fu.y]!=1)
		{
			vis[fu.x][fu.y] = 1;
			sum++;
			for(int i = 0;i < 4;i++)
			{
				int zx = fu.x + vec[i][0];
				int zy = fu.y + vec[i][1];
				if(check(zx,zy))
				{
					man ez;
					ez.x = zx;
					ez.y = zy;
					q.push(ez);	
				}
			}
		}	
	}	
	return;
}

int main()
{
	while(~scanf("%d %d",&w,&h),h,w)
	{
		sum = 0;
		memset(wd,'\0',sizeof(wd));
		memset(vis,0,sizeof(vis));
		for(int i = 0;i<h;i++)
		{
			scanf("%s",&wd[i]);
			for(int j = 0;j<w;j++)
			{
				if(wd[i][j] == '@')
				{
					mx = i;
					my = j;
				}
			}
		}
		bfs(mx,my);
		printf("%d\n",sum);
	}
	return 0;
}
```

### 2、最短路

#### 	（1）spfa（Bellman-Ford）

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>

#define ll long long

using namespace std;

const int MAXN = 10007;
const int inf = 0x3f3f3f3f;
const double pi=acos(-1);

struct worker
{
	int u;
	int v;
	int w;
	int ne;
};

int n,m,cnt;						//cnt：用来拓展道路列表的计数 
int dis[MAXN];						//存储目前起点到该点的最短路径 （存长度） 
int vis[MAXN];						//防止重复入队 
int times[MAXN];					//计数，防负环 
int head[MAXN];						// （存的是最后一条以某点为起点的道路在ed数组中的下标） 
worker ed[MAXN];					//存储所有道路的列表   

struct cmp 							//制定优先队列的排序标准 
{
	bool operator()(int a, int b) 	//给两个点 
	{
		return dis[a] > dis[b];		//将由起点到该点较短的排在前面 
	}
};

void addedge(int u,int v,int w)		//存入新道路 
{
	ed[cnt].u = u;
	ed[cnt].v = v;
	ed[cnt].w = w;
	ed[cnt].ne = head[u];			//指向上一条以该点为起点的道路 
	head[u] = cnt++;
}

void init()
{
	cnt = 0;
	for(int i = 1;i<=n;i++)
	{ 
		vis[i] = 0;
		times[i] = 0;
		head[i] = -1;
		dis[i] = inf;
	}		
	return;
}

bool spfa(int st)
{
	priority_queue<int, vector<int>, cmp>q;//新建一个优先队列,内存所有(要遍历的)目标点(路短的在前) 
	dis[st] = 0;
	vis[st] = 1;
	q.push(st);
	while(!q.empty())
	{
		int u = q.top();
		q.pop();
		vis[u] = 0;							//出队后，还有可能成为其他点的下家？ 
		for(int i = head[u];~i;i = ed[i].ne)//遍历以队列目前弹出点为起点的所有下家路径 
		{									//i ：调出所有路径的下标 
			int v = ed[i].v;				// 调出当前路径的终点 
			if(dis[v] > dis[u] + ed[i].w)	//比较dis数组中存储的最短路径长度和当前遍历长度 
			{
				dis[v] = dis[u] + ed[i].w;
				if(!vis[v])
				{
					vis[v] = 1;				//标记以在队列中，防止重复推入 
					q.push(v);				//将下家推入队列 
					if(++times[v] > n)		//验证有无出现负环现象 
						return 0;
				}		
			}	 
		}
	}
	return 1;
}

int main()
{
	while(scanf("%d%d",&n,&m)&&(n||m))
	{
		init();
		for(int i = 1;i<=m;i++)
		{
			int u,v,w;
			scanf("%d%d%d",&u,&v,&w);
			addedge(u,v,w);
			addedge(v,u,w);
		}
		spfa(1);
		printf("%d\n",dis[n]);
	}
	return 0;
}
```

#### （2）Dijkstra

```c++
//P4449
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi = acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7

struct node {
	int to;
	ll cost;
	bool operator < (const node& a)const {
		return cost > a.cost;	//优先队列强制设为以cost为关键词的小顶堆
	}
};

int n, m;
ll dis[maxn];
int wk[maxn];
vector<node>edge[maxn];

void addedge(int u, int v, ll w)
{
	edge[u].push_back(node{ v,w });
	//edge[v].push_back(node{ u,w });
}

void init()
{
	for (int i = 1; i <= n; i++) {
		edge[i].clear();
	}
}

void Dijkstra(int st)
{
	priority_queue<node>q;
	fill(dis, dis + n + 1, inf);
	dis[st] = 0;
	q.push(node{ st,0 });
	while (!q.empty()) {
		node x = q.top();
		q.pop();
		int v = x.to;
		ll d = x.cost;
		if (x.cost > dis[x.to]) {
			continue;
		}
		for (int i = 0; i < edge[v].size(); i++) {
			node y = edge[v][i];
			ll d2 = d + y.cost;//记录起点经过x到y的距离
			if (dis[y.to] > d2) {////更新到y的最短距离
				dis[y.to] = d2;
				q.push(node{ y.to,dis[y.to] });
			}
		}
	}
}

int main()
{
	ios;
	int s;
	ll w;
	cin >> n >> m >> s;
	for (int i = 1,u,v; i <= m; i++) {
		cin >> u >> v >> w;
		addedge(u, v, w);
	}
	Dijkstra(s);
	for (int i = 1; i <= n; i++) {
		cout << dis[i] << " \n"[i == n];
	}
	system("pause");
	return 0;
}
```

#### （3）Floyd 多源最短路径

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 107;//1e5+7 
const ll mod = 1000000007;//1e9+7

int n,m;
int dis[maxn][maxn];

void init()
{
	memset(dis,inf,sizeof(dis));
	n = -1;
} 

void floyd()
{
	for(int i = 0;i<=n;i++){
		dis[i][i] = 0;
	}
	for(int k = 0;k<=n;k++){
		for(int i = 0;i<=n;i++){
			for(int j = 0;j<=n;j++){
				dis[i][j] = min(dis[i][j],dis[i][k] + dis[k][j]);
			}
		}
	}
}

int main()
{
	ios;
	int ans,pos;
	while(cin>>m && m){
		init();
		for(int i = 1,u,v,w;i<=m;i++){
			cin>>u>>v>>w;
			n = max(n,max(u,v));
			dis[u][v] = dis[v][u] = w;
		}
		floyd();
		ans = inf;
		for(int i = 0,tmp;i<=n;i++){
			tmp = 0;
			for(int j = 0;j<=n;j++){
				tmp += dis[i][j];
			}
			if(ans > tmp){
				ans = tmp;
				pos = i;
			}
		}
		cout<<pos<<' '<<ans<<endl;
	}
	return 0;
}
```

#### （4）A* —K短路

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
#define inr register int 
using namespace std;
typedef long long ll;
const double pi = acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 1007;//1e5+7 
const ll mod = 1000000007;//1e9+7

struct node {
	int to, cost;
	bool operator < (const node& a)const {
		return cost > a.cost;	//优先队列强制设为以cost为关键词的小顶堆
	}
};

int n, m;
int dis[maxn];
int cnt[maxn];
vector<node>G[maxn];
vector<node>RG[maxn];

void addedge(int u, int v, int w)
{
	G[u].push_back(node{ v,w });
	RG[v].push_back(node{ u,w });
}

void Dijkstra(int st)
{
	priority_queue<node>q;
	fill(dis, dis + n + 1, inf);
	dis[st] = 0;
	q.push(node{ st,0 });
	while (!q.empty()) {
		node x = q.top();
		q.pop();
		int v = x.to;
		ll d = x.cost;
		if (x.cost > dis[x.to]) {
			continue;
		}
		for (int i = 0; i < RG[v].size(); i++) {
			node y = RG[v][i];
			ll d2 = d + y.cost;//记录起点经过x到y的距离
			if (dis[y.to] > d2) {////更新到y的最短距离
				dis[y.to] = d2;
				q.push(node{ y.to,dis[y.to] });
			}
		}
	}
}

struct F {
	int u, g, f;// u 为当前点 g 为当前点到s的距离，f = g+dis[(当前点)](因为dis是e到其他点的最短路，所以是一个准确的"估计值") 
	F(int x, int y, int z) : u(x), g(y), f(z) {}//因为A*是基于对后面方向“估计”的搜索算法，但是这里相当于提前知道了后面的路径长度
	bool operator < (const F& al) const {
		if (f == al.f) return g > al.g;
		else return f > al.f;//总体最短路向前排
	}
};

int A_star(int s, int e, int k)
{
	priority_queue<F>qu;
	for (int i = 1; i <= n; i++) {//记录每个点被遍历的次数
		cnt[i] = 0;
	}
	if (dis[s] == inf) {//起点不可达
		return -1;
	}
	qu.push(F(s, 0, dis[s]));//初始点
	while (!qu.empty()) {//A*本质上是一种带有策略的广度优先搜索
		F tp = qu.top();
		qu.pop();
		int u = tp.u;
		cnt[u]++;
		if (cnt[e] == k) {//如果当前可达终点的路径已经达到K条
			return tp.g;//返回当前路径长度
		}
		if (cnt[u] > k)continue;// 当前点经过的次数大于k就不用考虑这个点 
		for (int i = 0; i < G[u].size(); i++) {
			int v = G[u][i].to, w = G[u][i].cost;
			qu.push(F(v, tp.g + w, dis[v] + tp.g + w));// g = 当前点到s的距离+当前点到v的距离 ; f = dis[v]+g
		}
	}
	return -1;
}

int main()
{
	ios;
	int st, nd, K;
	cin >> n >> m;
	for (int i = 1,u,v,w; i <= m; i++) {
		cin >> u >> v >> w;
		addedge(u, v, w);
	}
	cin >> st >> nd >> K;
	Dijkstra(nd);
	if (st == nd) {//起点和终点一样多找一条
		K++;
	}
	cout << A_star(st, nd, K) << endl;
	return 0;
}c++
```



### 3、最小生成树

#### （1）Kruskal（点多边少）

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>

#define ll long long

using namespace std;

const int MAXN = 10007;
const int inf = 0x3f3f3f3f;
const double pi=acos(-1);

struct way
{
	int u;
	int v;
	int w;
};

int n,m,sum,ans;
int pre[107];					//存储父节点 
int height[107];				 
way ed[10007];

void init()
{
	ans = 0;
	sum = 0;
	for(int i =1;i<=m;i++)
		pre[i] = i;
}

int found(int x)
{
	if(pre[x] != x)
	{
		pre[x] = found(pre[x]);
		return pre[x];
	}
	else
		return x;
}

void unite(int a, int b)
{
    int x = found(a);
    int y = found(b);
    if(height[x] == height[y])
    {
        pre[y] = x;
        height[x]++;
    }
    else
    {
        if(height[x] < height[y])
            pre[x] = y;
        else
            pre[y] = x;
    }
    return ;
}

bool cmp(way a,way b)
{
	return a.w < b.w;
}

void kruskal()
{
	sort(ed+1,ed+n+1,cmp);			//短的路径优先取出，并入树中 
	for(int i = 1;i <= n;i++)
	{
		if(found(ed[i].u) != found(ed[i].v))	//若终点与起点不在一个集合，说明终点还未进树 
		{										//而由于已经sort，故一定是最短的路径 
			unite(ed[i].u,ed[i].v);				// 合并两点 
			ans += ed[i].w;
			sum++;
		}
	}
}

int main()
{
	while(~scanf("%d%d",&n,&m)&&n)
	{
		init();
		for(int i = 1;i<=n;i++)
			scanf("%d%d%d",&ed[i].u,&ed[i].v,&ed[i].w);
		kruskal();
		if(sum == m-1)
			printf("%d\n",ans);
		else
			printf("?\n");
	}
	return 0;
}
```

#### （2）prim（点少边多）

```c++
#include <bits/stdc++.h>
#define ll long long
#define inf 0x3f3f3f3f
using namespace std;
const int MAXN = 1007;

struct point{
	double x;
	double y;
};

int n;
int vis[MAXN];
double dis[MAXN];
double ed[MAXN][MAXN];
point p[MAXN];

double edlen(point a,point b) //勾股定理求边长 
{
	return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));
}

void init()
{
	memset(vis,0,sizeof(vis));
	for(int i = 1;i<=n;i++)
	{
		for(int j = 1;j<=n;j++)
		{
			ed[i][j] = inf; //将初始边长都定义为无穷大 
		}
		ed[i][i] = 0;  //自己和自己的距离为0 
	}
}

double prim()
{
	double res = 0,min;  //min：暂时记录当前最短路径 
	for(int i = 1;i<=n;i++)
	{
		dis[i] = ed[1][i]; //先从第一个点开始，把所有的距离变为与第一个点的距离 
	}
	vis[1] = 1; //标记已遍历到 
	for(int i = 1;i<=n;i++)
	{
		min = inf;  //初始化为无穷大 
		int k = 1;	//代表即将遍历的节点（开始） 
		for(int j = 1;j<=n;j++)  
		{
			if(!vis[j]&&dis[j]<min) //逐点比较，找出当前的最小边（并且那个点还没进树） 
			{
				k = j;
				min = dis[j];
			}
		}
		vis[k] = 1;//（在这个点进树后标记一下） 
		res += dis[k]; //（进树） 
		for(int j = 1;j<=n;j++)  //防止漏下一些点 
		{
			if(!vis[j]&&dis[j]>ed[k][j])
				dis[j] = ed[k][j];
		}
	}
	return res;
}
 
int main()
{
	while(~scanf("%d",&n))
	{
		init();
		for(int i = 1;i<=n;i++)
			scanf("%lf%lf",&p[i].x,&p[i].y);
		for(int i = 1;i<=n;i++)
		{
			for(int j = 1;j<=n;j++)
			{
				ed[i][j] = edlen(p[i],p[j]);
			}	
		}
		printf("%.2f\n",prim());
	}
	return 0;
}

```



### 4.最大流

#### Dinic弧优化最大流

```c++
//Dinic弧优化最大流：
/*
每次增广一条路后可以看做“榨干”了这条路，既然榨干了就没有再增广的可能了。
但如果每次都扫描这些“枯萎的”边是很浪费时间的。
那我们就记录一下“榨取”到那条边了，然后下一次直接从这条边开始增广，
就可以节省大量的时间。这就是 当前弧优化 。
具体怎么实现呢，先把链式前向星的head数组复制一份，
存进cur数组，然后在cur数组中每次记录“榨取”到哪条边了
*/ 
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
const int maxn = 100010;
const int maxm = 1000100;
const int inf = 0x3f3f3f3f;
//如果边的流量很大，总最大流可能会爆int,那么改完一些变量类型为longlong之后这里也要改成0x3f3f3f3f3f3f3f3f
struct edge {
	int v, w, ne;
}ed[maxm];
int n, m, cnt;
int head[maxn], dis[maxn], cur[maxn];
void init() {
	cnt = 0;
	memset(head, -1, sizeof(head));//这里如果有时间上的需求也可以改成for循环的，避免这样全部初始化
}
void addDan(int u, int v, int w) {//单向边双向边计算有差别，需要不同的加边函数 
	ed[cnt].v = v; ed[cnt].w = w;
	ed[cnt].ne = head[u]; head[u] = cnt++;
	ed[cnt].v = u, ed[cnt].w = 0;
	ed[cnt].ne = head[v]; head[v] = cnt++;
}
void addShuang(int u, int v, int w) {
	ed[cnt].v = v; ed[cnt].w = w;
	ed[cnt].ne = head[u]; head[u] = cnt++;
	ed[cnt].v = u, ed[cnt].w = w;
	ed[cnt].ne = head[v]; head[v] = cnt++;
}
int bfs(int st, int en) {
	queue<int>q;
	memset(dis, 0, sizeof(dis));
	dis[st] = 1;
	q.push(st);
	while (!q.empty()) {
		int u = q.front(); q.pop();
		if (u == en)return 1;
		for (int s = head[u]; ~s; s = ed[s].ne) {
			int v = ed[s].v;
			if (dis[v] == 0 && ed[s].w > 0) {
				dis[v] = dis[u] + 1; q.push(v);
			}
		}
	}
	return dis[en] != 0;
}
int dfs(int st, int en, int flow) {
	int ret = flow, a;
	if (st == en || flow == 0)return flow;
	for (int& s = cur[st]; ~s; s = ed[s].ne) {
		int v = ed[s].v;
		if (dis[v] == dis[st] + 1 && (a = dfs(v, en, min(ret, ed[s].w)))) {
			ed[s].w -= a;
			ed[s ^ 1].w += a;
			ret -= a;
			if (!ret)break;
		}
	}
	if (ret == flow)dis[st] = 0;
	return flow - ret;
}
int dinic(int st, int en) {//源点，汇点 
	int ans = 0;
	while (bfs(st, en)) {
		for (int s = 0; s <= n; s++) //这里要将所有存在的点都处理,可能不是或不止0~n
			cur[s] = head[s];
		ans += dfs(st, en, inf);
	}
	return ans;
}
int main()
{
	ios;
	while(cin>>m>>n){
		init();
		int u,v,w;
		for(int i = 1;i<=m;i++){
			int u,v,w;
			cin>>u>>v>>w;
			addDan(u,v,w);
		}
		int ans = dinic(1,n);
		cout<<ans<<endl;	
	}
	return 0;
}
```

##### 最大流解决匹配问题（无源汇点 拆点多对一匹配）

```c++
int main()//这就是建图吗？i了i了  
{
	ios;
	int st,nd;
	int f,d; 
	while(cin>>n>>f>>d){
		init();
		st = 0;//没有指定的源点和汇点 
		nd = f+2*n+d+1;//那就自己造两个 
		for(int i = 1;i<=f;i++){//源点与所有食物建路 
			addDan(0,i,1);
		}
		for(int i = f+1;i<=f+n;++i){//在牛上加一条路，防止多个食物或饮料与一头牛匹配 
			addDan(i,i+n,1);// （牛：我裂开了 ）
		}
		for(int i = f+2*n+1;i<=f+2*n+d;i++){//所有饮料与汇点建路 
			addDan(i,f+2*n+d+1,1);
		}
		for(int i = 1;i<=n;i++){//牛与喜爱的食物和饮料建路 
			int fx,dx; 
			cin>>fx>>dx;
			while(fx--){
				int pos;
				cin>>pos;
				addDan(pos,i+f,1);
			}
			while(dx--){
				int pos;
				cin>>pos;
				addDan(f+n+i,f+2*n+pos,1);
			}
		}
		n = nd;//dinic要将所有存在的点都处理，故要更新点的数量 
		int ans = dinic(st,nd);
		cout<<ans<<endl;
	}
	return 0;
}
```

### 5.最小割

#### tarjan算法--求无向图的割点和桥

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#include <map>
using namespace std;
const int MAXN=10010,MAXM=100010;
//点的下标切记转换成由1~n
struct Edge{
   int to,next;
   bool cut;  //是否为桥的标记*******
}edge[MAXM];  //边数组
/*    遍历点u的临接边
    for(int i=head[u];i!=-1;i=edge[i].next)
    {   edge[i]      } //edge[i]即为边
*/
int head[MAXN],tot;
int Low[MAXN],DFN[MAXN],Stack[MAXN];
int Index,top;
bool Instack[MAXN];
bool cut[MAXN];    //是否为割点的标记*********
int add_block[MAXN];   //删除一个点后增加的连通块
int bridge;     //记录桥的个数*******
 
void init(){  //加边前先初始化
   memset(DFN,0,sizeof(DFN));
   memset(Instack,false,sizeof(Instack));
   memset(add_block,0,sizeof(add_block));
   memset(cut,false,sizeof(cut));
   memset(head,-1,sizeof(head));
   tot=Index=top=bridge=0;
}
 
void add_edge(int u,int v){  //添加无向边，只需调用一次！！！！！！！！！
    edge[tot].to=v;  edge[tot].next=head[u] ; edge[tot].cut=false;
    head[u]=tot++;
    edge[tot].to=u;  edge[tot].next=head[v] ; edge[tot].cut=false;
    head[v]=tot++;
}
 
void Tarjan(int u,int pre){
    int v;
  //  cout<<u<<" "<<pre<<endl;
    Low[u]=DFN[u]=++Index;
    Stack[top++]=u;
    Instack[u]=true;
    int son=0;
    for(int i=head[u];i!=-1;i=edge[i].next){
         v=edge[i].to;
         if(v==pre)continue;
         if(!DFN[v]){     //如果没有访问过v
            son++;
            Tarjan(v,u);
            if(Low[u]>Low[v])Low[u]=Low[v];
            //判断无向边（u,v）是否是桥
            if(Low[v]>DFN[u]){
                bridge++;
                edge[i].cut=true;
                edge[i^1].cut=true;
            }
            //判断u是否为割点
            if(u!=pre&&Low[v]>=DFN[u]){
                cut[u]=true;
                add_block[u]++;
            }
         }
         else if(Low[u]>DFN[v])
            Low[u]=DFN[v];
    }
    if(u==pre&&son>1)cut[u]=true;
    if(u==pre)add_block[u]=son-1;
    Instack[u]=false;
    top--;
}
 
void solve(int N){  //  寻找割顶和桥,N为题目中结点数
     for(int i=1;i<=N;i++)
     if(!DFN[i])Tarjan(i,i);     //对于每一个连通分量都调用一次
}

```



### 6.拓扑排序

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
typedef long long ll;

using namespace std;

const int maxn = 10007;
const int inf = 0x3f3f3f3f;
const double pi = acos(-1);

int n, m, cnt;
bool rel[30][30];
int ans[30];
int indeg[30];
int ind[30];

void addrel(int a, int b)
{
	rel[a][b] = 1;
	indeg[b]++;
}

void init()
{
	cnt = 0;
	memset(rel, 0, sizeof(rel));
	memset(indeg, 0, sizeof(indeg));
}


int topo_sort()
{
	cnt = 0;
	bool pd = 0;
	memcpy(ind, indeg, sizeof(indeg));
	priority_queue<int, vector<int>, greater<int> > q;

	for (int i = 0; i < n; i++) {
		if (ind[i] == 0) {//入度为零就可入队 
			q.push(i);
		}
	}
	while (!q.empty()) {//搜索 
		if (q.size() > 1) {
			pd = 1;
		}
		int u = q.top();    //const int u？？？ 
		ans[++cnt] = u;
		q.pop();
		for (int i = 0; i < n; i++) {
			if (rel[u][i]) {
				ind[i]--;//出队后，其父亲们入度都减一 
				if (ind[i] == 0) {
					q.push(i);
				}
			}
		}
	}
	if (cnt != n) {
		return -1;
	}
	if (pd == 1) {
		return 0;
	}
	return 1;
}

string st;

int main()
{
	ios;
	while (cin >> n >> m) {
		if (!(n || m)) {
			break;
		}
		int nw = 0, flag = 0;
		for (int i = 1; i <= m; i++) {
			cin >> st;
			if (!flag) {
				nw++;
				if (st[1] == '<') {
					addrel(st[0] - 'A', st[2] - 'A');
				}
				else {
					addrel(st[2] - 'A', st[0] - 'A');
				}
				flag = topo_sort();
			}
		}
		if (flag == -1) {
			cout << "Inconsistency found after " << nw << " relations." << endl;
		}
		else if (flag == 1) {
			string ast = "";
			for (int i = 1; i <= n; i++) {
				ast += ('A' + ans[i]);
			}
			cout << "Sorted sequence determined after " << nw << " relations: " << ast << "." << endl;
		}
		else {
			cout << "Sorted sequence cannot be determined." << endl;
		}
		init();
	}
	return 0;
}
```



## 五、数据结构

### 0.简单二叉树

#### （1）数组实现前序遍历

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7

struct node{
	int v;
	int left,right;
}tree[maxn];

int cnt = 0;

int build(int root,int v)
{
	if(root == -1){
		root = ++cnt;
		tree[root].v = v;
		tree[root].left = tree[root].right = -1;
	}
	else if(v <= tree[root].v){
		tree[root].left = build(tree[root].left,v);
	}
	else{
		tree[root].right = build(tree[root].right,v);
	}
	return root;
}

int flag;

void dfs(int root)
{
	if(flag == 1){
		cout<<tree[root].v;
		flag = 0;
	}
	else cout<<' '<<tree[root].v;
	if(tree[root].left != -1){
		dfs(tree[root].left);
	}
	if(tree[root].right != -1){
		dfs(tree[root].right);
	}
}

int main()
{
	ios;
	int n;
	while(cin>>n){
		cnt = 0;
		memset(tree,0,sizeof(tree));
		flag = 1;
		int root = -1;
		int tmp;
		for(int i = 1;i<=n;i++){
			cin>>tmp;
			root = build(root,tmp);
		}
		dfs(root);
		cout<<endl;
	}
	return 0;
}
```

#### （2）指针实现前序遍历

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7

struct node{
	int v;
	node *left,*right;
}*root;

node* build(node *root,int v)
{
	if(root == NULL){
		root = new node();
		root->v = v;
		root->left = root->right = NULL;
	}
	else if(v <= root->v){
		root->left = build(root->left,v);
	}
	else{
		root->right = build(root->right,v);
	}
	return root;
}

int flag;

void dfs(node *root)
{
	if(flag == 1){
		cout<<root->v;
		flag = 0;
	}
	else cout<<' '<<root->v;
	if(root->left != NULL){
		dfs(root->left);
	}
	if(root->right != NULL){
		dfs(root->right);
	}
}

int main()
{
	ios;
	int n;
	while(cin>>n){
		flag = 1;
		root = NULL;
		int tmp;
		for(int i = 1;i<=n;i++){
			cin>>tmp;
			root = build(root,tmp);
		}
		dfs(root);
		cout<<endl;
	}
	return 0;
}
```



### 1、树状数组

```c++
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <set>

#define ll long long

using namespace std;

const int MAXN = 50007;
const int inf = 0x3f3f3f3f;
const double pi=acos(-1);

int n;

int a[MAXN];
int c[MAXN];

int lowbit(int x)				//原理：计算机数据存储通过补码存储，由于负数补码的特殊取反 
{								// 再进位的特性正负数按位与后得到的正式改数二进制表示最后 
	return x & (-x);			//一位”1“的位权。
}								
								
void update(int p,int k)		// 
{
	while(p<=n)
	{
		c[p] += k;
		p += lowbit(p);
	}
}

int getsum(int p)				 //查询区间和时：通过以一个数的二进制表示的各位”1“的位权作为
{								//来分割存储当前数的前缀和（或者说在查询一个数的前缀和时，依次调取 
	int res = 0;				//按其二进制表示的各位'1'的位权所存储的数据并求和得到该数的前缀和） 
	while(p)					//例如：7[111 = 100(4) + 10(2) + 1]则代表查询7的前缀和时，会分别 
	{							//查询覆盖面为1、2、4的区间和。 而查询时，则按照”去1“来达到查询 
		res += c[p];			//有相关覆盖面的数组的下标。 
								//如：7（111）  = 110（6） + 1；res = c[7] 
		p -= lowbit(p);			//6(110) = 100 + 10;res = c[7]+c[6]
	}							//4(100) = 100 + 0;res = c[7]+c[6]+c[4]
	return res;					//以此达到log(n)查询区间和的目的 
}

void init()
{
	memset(a,0,sizeof(a));
	memset(c,0,sizeof(c));
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		update(i,a[i]);
	}
}

int main()
{
	int t;
	int cot = 1;
	scanf("%d",&t);
	while(t--)
	{
		printf("Case %d:\n",cot);
		cot++;
		scanf("%d",&n);
		init();
		char ch[9];
		while(scanf("%s",&ch)&&ch[0] != 'E')
		{
			int u,v;
			scanf("%d%d",&u,&v);
			if(ch[0] == 'Q')
			{
				int ans;
				ans = getsum(v) - getsum(u-1);
				printf("%d\n",ans);
			}
			if(ch[0] == 'A')
			{
				update(u,v);
			}
			if(ch[0] == 'S')
			{
				update(u,-v);
			}
		}
	}
	
}
```



### 2、线段树

```c++
#include<bits/stdc++.h>

#define MAXN (int) 1e5 + 1000
typedef long long ll;
using namespace std;

int a[MAXN];
ll tree[(MAXN) * 4];  //为了使树的父子关系简单明确（2*o）要把数组开到2*2^k的大小
ll lazy[(MAXN) * 4]; 	//lazy数组用于标记该节点下需不需要更新信息（以及更新值） 
// 一般开到4*n的空间防RE 
void build(int o,int l,int r) //递归建树 
{  //o : 树的当前节点，l:左端点 r:右端点 
	lazy[o] = 0;
	if(l == r) //当左右端点相等时，即找到了叶子节点，直接赋值即可 
	{
		tree[o] = a[l];
		return ;
	}
	int mid = (l + r) / 2;  // 劈开左右分别向下构建 
	build(o * 2,l,mid); //构建左子树 
	build(o * 2 + 1,mid + 1,r); //构建右子树 
	tree[o] = tree[o * 2] + tree[o * 2 + 1]; //每个非叶节点都为其两个子节点的和 
}

void  update(int o,int l,int r,int pos,int x) //二分查找的单点修改 
{  //当前树节点、节点区间左端点、节点区间右端点、待改索引、新值 
	if(l == r) //当递归到叶子节点时（二分终点） 
	{//表明来到目标 
		tree[o] = x; //修正值 
		return ;		
	}
	int mid = (l + r) / 2; //二分查找 
	if(pos <= mid) //索引在左 
	{
		update( o * 2,l,mid,pos,x);  //向左找 
	}
	else//索引在右 
		update(o * 2 + 1,mid + 1,r,pos,x); //向右找 
	tree[o] = tree[o * 2] + tree[o * 2 + 1];  //当返回时，所有递归经过的节点都会被更新 
}

void pushdown(int o,int l,int r) //向下层更新区间变动 
{//当前节点、节点区间范围 (左、右) 
	if(lazy[o]) //判断当前节点是否被lazy标记过 
	{
		int mid = (l + r) / 2; //向下层更新 
		tree[o * 2] += (mid - l + 1 ) * lazy[o];  
		tree[o * 2 + 1] += (r - mid) * lazy[o];
		lazy[o * 2] += lazy[o];
		lazy[o * 2 + 1] += lazy[o];
		lazy[o] = 0; //更新完毕，去掉lazy标记 
	}
}

void qadd(int o,int l,int r,int al,int ar,ll x) //区间加值修改 
{ //节点、节点区间（左、右）、待更新区间（左、右） 
	if(al <= l && r <= ar)		//若当前节点全部就在待更新区间中 
	{
		lazy[o] += x;  //打个lazy标记，有必要时再向下更新 
		tree[o] += 1LL * (r - l + 1) * x; //*1LL:强制转换为long long 
		return;		//将当前节点更新（其实是更新其区间长度遍） ，直接返回即可。 
	}//（其下有多少叶子就要更新多少遍（多少倍））
	pushdown(o,l,r); //该层没有合规节点，先向下更新一层（把以前的lazy更新了）再查询 
	int mid = (l + r) / 2;  //向下继续查找合规节点（并更新） 
	if(al <= mid)
		qadd(o * 2,l,mid,al,ar,x);
	if(ar > mid)
		qadd(o * 2 + 1,mid + 1,r,al,ar,x);
	tree[o] = tree[o * 2] + tree[o * 2 + 1]; //最后要把改的上层的更新掉(上面的必须是最新的)
}//因为lazy只能暂缓向下更新，其上的管不着 

long long query(int o,int l,int r,int ql,int qr)
{
	if(ql <= l && r <= qr)
	{
		return tree[o];
	}
	int mid = (l + r) / 2;
	long long res = 0;
	pushdown(o,l,r); //询问时，该节点先查询一下lazy，更新为最新值 
	if(ql <= mid)
	{
		res += query(o * 2,l,mid,ql,qr);
	}
	if(qr > mid)
	{
		res += query(o * 2 + 1,mid + 1,r,ql,qr);
	}
	return res;
}



/*
//版Ⅱ 
void qadd(int o,int l,int r,int al,int ar,ll x)
{
	if(al == l && r == ar)
	{
		lazy[o] += x;
		tree[o] += 1LL * (r - l + 1) * x;
		return;
	}
	pushdown(o,l,r);
	int mid = (l + r) / 2;
	if(qr <= mid)
	{
		qadd(o * 2,l,mid,ql,qr,x);
	}
	else if(mid + 1 <= ql)
	{
		qadd(o * 2 + 1,mid + 1,r,ql,qr,x);
	}
	else
	{
		qadd(o * 2,l,mid,ql,mid,x);
		qadd(o * 2 + 1,mid + 1,r,mid + 1,qr,x);
	}
	tree[o] = tree[o * 2] + tree[o * 2 + 1];
}


long long query(int o,int l,int r,int ql,int qr) //递归查询 
{  //当前树节点、待查区间左端点、待查区间右端点、(<==就是当前节点涵盖的区间)查询左端点、查询右端点 
	if(l == ql && r == qr) //如果当前节点正好满足查询区间，直接返回 
	{
		return tree[o];
	}
	int mid = (l + r) / 2;  // 二分劈开左右查找 
	pushdown(o,l,r);
	if(qr <= mid)  //如果查询区间在中间之左 
	{  //将待查询区间缩小为左半部分 （仅查询左子树） 
		return query(o * 2,l,mid,ql,qr); //向下查询 
	}
	else if(mid + 1 <= ql) //若查询区间在右边 
	{  //将待查询区间缩小为右半部分 （仅查询右子树） 
		return query(o * 2 + 1,mid + 1,r,ql,qr); //向下查找 
	}
	else  //如果查询区间横跨左右 
	{//左右两边分开查找 （左右子树都要向下查询） 
		return query(o * 2,l,mid,ql,mid) + //最后把左右查询结果加起来 
			   query(o * 2 + 1,mid + 1,r,mid+1,qr);
	}
}
*/

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	build(1,1,n);
	while(m--){
		int c;
		scanf("%d",&c);
		if(c == 1){
			int sl,sr,sx;
			scanf("%d%d%d",&sl,&sr,&sx);
			qadd(1,1,n,sl,sr,sx);
		}
		else if(c == 2){
			int dl,dr;
			scanf("%d%d",&dl,&dr);
			ll ans = query(1,1,n,dl,dr);
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

### 3.并查集

#### （1）普通并查集

```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;
int pre[10007];
int height[10007];
void init()
{
	for(int i =1;i<=n;i++)
		pre[i] = i;
}
int found(int x)		//路径压缩只能在不需要记录路径的情况下使用 
{
	if(pre[x] != x)
	{
		pre[x] = found(pre[x]);
		return pre[x];
	}
	else
		return x;
}
//合并优化（尽量减小合并后链的长度） （极值优化） (可能报错？？？)
void unite(int a, int b)
{
    int x = found(a);
    int y = found(b);
//    if(x != y)
//    {
//        pre[y] = x;
//    }
    if(height[x] == height[y])
    {
        pre[y] = x;
        height[x]++;
    }
    else
    {
        if(height[x] < height[y])
            pre[x] = y;
        else
            pre[y] = x;
    }
    return ;
}
/*
void unite(int a,int b)
{
	int x = found(a);
	int y = found(b);
	if (x != y)
		pre[y] = x;
	return;
}
*/
int main()
{
	int k,v,sum;
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		sum = 0;
		init();
		for(int i = 1;i<=m;i++)
		{
			scanf("%d%d",&k,&v);
			unite(k,v);
		}
		for(int i = 1;i<=n;i++)
		{
			if (found(i) == i)
				sum++;
		}
		printf("%d\n",sum);
	}
	return 0;
}
```



#### （2）加权并查集

```c++
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 50007*3;
const int inf = 0x3f3f3f3f;

int n,k,ans;
int pre[MAXN];

void init()
{
	ans = 0;
	for(int i = 1;i <= n*3;++i)
	{
		pre[i] = i;
	}
}


int found(int x)		
{
	if(pre[x] != x)
	{
		pre[x] = found(pre[x]);
		return pre[x];
	}
	else
		return x;
}

int unite(int a,int b)
{
	int x = found(a);
	int y = found(b);
	pre[x] = y;
}

int main()
{
	scanf("%d%d",&n,&k);
	init();	
	for(int i = 1;i<=k;++i)
	{
		int pd,a,b;
		scanf("%d%d%d",&pd,&a,&b);
		if(a<=0 || b<=0 || a>n || b>n)
		{
			ans++;
			continue;
		}
		if(pd == 2 && a==b)
		{
			ans++;
			continue;
		}
		if(pd == 1)
		{
			if(found(a) == found(b+2*n)||found(b) == found(a+2*n))
			{
				ans++;
				continue;
			}
			unite(a,b);
			unite(a+n,b+n);
			unite(a+n*2,b+n*2);			
		}
		else
		{
			if(found(a) == found(b) || found(a) == found(b+2*n))
			{
				ans++;
				continue;
			}
			unite(a,b+n);
			unite(a+n,b+2*n);
			unite(a+2*n,b);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```



### 4、二分图

#### （1）二分图最大匹配

##### 	（1）邻接矩阵

（A:B）（在第B方点少得情况下推荐使用）

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn = 1005;
int n, m;
int G[maxn][maxn], use[maxn];
bool vis[maxn];
bool find(int x) {
	for (int s = 1; s <= m; s++)
		if (G[x][s] && !vis[s]) {
			vis[s] = 1;
			if (use[s] == 0 || find(use[s])) {
				use[s] = x; return 1;
			}
		}
	return 0;
}
int solve() {
	memset(use, 0, sizeof(use));
	int ans = 0;
	for (int s = 1; s <= n; s++) {
		memset(vis, 0, sizeof(vis));
		if (find(s))ans++;
	}
	return ans;
}
```



##### 	（2）vector形式

（A:B）（在第B方点多且分散开得情况下推荐使用）

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
const int maxn = 1005;
int n, m, use[maxn];
vector<int>G[maxn];
bool vis[maxn];
bool find(int x) {//别忘了每次使用前清空G
	int sz = G[x].size();
	for (int s = 0; s < sz; s++) {
		int v = G[x][s];
		if (!vis[v]) {
			vis[v] = 1;
			if (use[v] == 0 || find(use[v])) {
				use[v] = x; return 1;
			}
		}
	}
	return 0;
}
int solve() {
	memset(use, 0, sizeof(use));
	int ans = 0;
	for (int s = 1; s <= n; s++) {
		memset(vis, 0, sizeof(vis));
		if (find(s))ans++;
	}
	return ans;
}
```

##### 	（3）hall定理

​      二分图G中的两部分顶点组成的集合分别为X, Y(假设有|X|≤|Y||X|≤|Y|)。G中有一组无公共点的边，一端恰好为组成X的点(也就是存在完美匹配)的充分必要条件是：X中的任意k个点至少与Y中的k个点相邻**，即**对于X中的一个点集W ，令N(W)为W的所有邻居， 霍尔定理即对于任意W，|W|≤|N(W)|

​       推论：

假设两边的点集分别为X，Y，则二分图的最大匹配数为   |X|−max{|W|−|N(W)|}   ，其中W是X的子集
这个推论就很厉害啦，对于一些特殊的题目，它可以免去建图而直接求最大匹配。



### 5.最近公共祖先（LCA）

#### 倍增法

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const int maxn = 500010;
const int DEG = 20;

struct node{
	int v;
	int w;
	int ne;
};

int n,m;
int cnt;
int fa[maxn][DEG];//父亲：fa[i][j] = i的2^j的父亲节点是谁
int dep[maxn];//当前节点的深度 
int dis[maxn];
int head[maxn];
node ed[maxn<<1];

void init()//初始化链式前向星 
{
	cnt = 0;
	memset(head,-1,sizeof(head));
	memset(dep,0,sizeof(dep));
	memset(dis,0,sizeof(dis));
}

void add(int u,int v,int w)//前向星加边 
{
	ed[cnt].v = v;
	ed[cnt].w = w;
	ed[cnt].ne = head[u];
	head[u] = cnt++;
}

void dfs(int u,int f,int dp)//dfs初始化LCA（倍增法）
{//根节点号，他爸爸，深度(初始为零) 
	fa[u][0] = f;
	dep[u] = dp;
	for (int i = 1; i < DEG; i++) {//树上倍增 
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}//u的2^i父亲 = (u的2^i-1的父亲)的2^i-1的父亲				
	for(int i = head[u];~i;i = ed[i].ne){
		int to = ed[i].v;
		if(to == f) continue;
		dis[to] = dis[u]+ed[i].w;
		dfs(to,u,dp+1);			
	}
}

void initlca()//初始化lca 
{
	dep[1] = 1;
	dis[1] = 0;//无论怎么样的树，都可以把1视为根节点
	dfs(1,-1,0);
}

int lca(int u,int v)
{
	if(dep[u] > dep[v]){//统一成u浅v深方便运算
		swap(u,v);
	}	
	for(int i = 0;i<DEG;i++){//用倍增法将两个点提升到相同深度（的相应祖宗）
		if(dep[v]-dep[u]>>i&1){//二进制特性，一定能跳到深度相同
			v = fa[v][i];
		}
	}
	if(u == v){//如果发现浅的那个已经是深的祖宗了，就返回浅的
		return u;
	}
	for(int i = DEG-1;i>=0;i--){//两者同时倍增
		if(fa[u][i] != fa[v][i]){//一直找到不是他们共同祖先的第一个（由浅至深的）
			u = fa[u][i];
			v = fa[u][i];
		}
	}
	return fa[v][0];//一直找到不是他们共同祖先的第一个（由浅至深的） 
}

int main()
{
	ios;
	int T;
	cin>>T;
	while(T--){
		init();
		cin>>n>>m;
		for(int i = 1;i<n;i++){
			int u,v,w;
			cin>>u>>v>>w;
			add(u,v,w);
			add(v,u,w);
		}
		initlca();
		for(int i = 1;i<=m;i++){
			int u,v;
			cin>>u>>v;
			int ans = dis[u] + dis[v] - 2*dis[lca(u,v)];
			cout<<ans<<endl;	
		}
	}
	return 0;
}

```

### 6.树上启发式合并

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7

int n,mx,Son;
ll sum = 0;
ll ans[maxn];
int col[maxn];//颜色数组 
int son[maxn];//记录重儿子 
int siz[maxn];//记录子树的的大小 
int cnt[maxn];//计数数组 
vector<int>G[maxn];

void getson(int x,int fa)//树链剖分寻找各节点重儿子 
{
	siz[x] = 1;
	for(int i = 0;i<G[x].size();i++){
		int to = G[x][i];
		if(to != fa){
			getson(to,x);
			siz[x] += siz[to];//递归计算子树大小 
			if(siz[to] > siz[son[x]]){
				son[x] = to;//剖分重链（重儿子） 
			}
		}
	}
}

void dfs(int x,int fa,int val)//递归遍历轻儿子子树，查询数据 
{
	cnt[col[x]] += val;//这里可能会因题目而异 
	if(cnt[col[x]] > mx){//更新主要颜色结点数 
		mx = cnt[col[x]];
		sum = col[x];
	}
	else if(cnt[col[x]] == mx){
		sum += (ll)col[x]; 
	}
	for(int i = 0;i<G[x].size();i++){
		int to = G[x][i];
		if(to == fa || to == Son){//先不遍历重儿子 
			continue ;
		} 
		dfs(to,x,val);
	}
}

void dsu(int x,int fa,int opt)//树上启发式合并 
{
	for(int i = 0;i<G[x].size();i++){
		int to = G[x][i];
		if(to == fa || to == son[x]){//跳过重儿子，先暴力统计轻边的数据，0代表需要消除影响 
			continue ;
		}
		dsu(to,x,0); 
	}
	
	if(son[x]){//如果存在重儿子，有记录的统计重儿子的数据 
		dsu(son[x],x,1);
		Son = son[x];
	}
	dfs(x,fa,1);//在统计完所有结点并保留重儿子的的数据后，再暴力统计一遍轻儿子的数据 
	Son = 0;
	ans[x] = sum;//记录答案 
	if(!opt){//如果需要消除影响 
		dfs(x,fa,-1);//反向加值消除影响 
		sum = 0;
		mx = 0;
	}
}


int main()
{
	ios;
	cin>>n;
	for(int i = 1;i<=n;i++){
		cin>>col[i];
	}
	for(int i = 1,u,v;i<n;i++){
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	getson(1,0);
	dsu(1,0,0);
	for(int i = 1;i<=n;i++){
		cout<<ans[i]<<' ';
	}
	return 0;
}
```

### 7.树链剖分

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
#define inr register int 
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 200007;//1e5+7 

#define mid ((l+r)>>1)
#define lson o<<1,l,mid
#define rson o<<1|1,mid+1,r
#define len (r-l+1)

struct node{
	int u,v,ne;
}ed[maxn];

int n,m,rot,mod;
int wt[maxn],wn[maxn],head[maxn],el = 0;
//权值、前向星、数组长度 
int tree[maxn<<2],laz[maxn<<2];//线段树和lazy数组 
int son[maxn],id[maxn],fa[maxn],dep[maxn],siz[maxn],top[maxn],cnt = 0;
//son[]重儿子编号,id[]新编号,fa[]父亲节点,dep[]深度,siz[]子树大小,top[]当前链顶端节点 ,cnt dfs_clock/dfs序
 
 int read()
{
	char ch=0;
	int res=0,flag=1;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')	flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		res=res*10+ch-'0';
		ch=getchar();
	}
	return flag*res; 
}
 
/*--------------------------链式前向星---------------------------*/ 
 
inline void init() {												//初始化函数 
	for (int i = 1; i <= n; i++){
		head[i] = -1;
	}
	el = 0;
}

inline void add(int u,int v)//链式前向星加边 
{
	ed[el].u = u;
	ed[el].v = v;
	ed[el].ne = head[u];
	head[u] = el++;
}

inline void addS(int u,int v)
{
	add(u,v);
	add(v,u);
} 

/*---------------------------线段树---------------------------*/ 

inline void pushdown(int o,int le){ //下推lazy 
	 laz[o<<1] += laz[o];
	 laz[o<<1|1] += laz[o];
	tree[o<<1] += laz[o] * (le - (le >> 1));//下层树上结点更新lazy 
	tree[o<<1|1] += laz[o] * (le >> 1); 
	tree[o<<1] %= mod; 
	tree[o<<1|1] %= mod;
	 laz[o] = 0; //当前层lazy归零 （已下推） 
}

inline void build(int o,int l,int r)//建树：根、左右范围 
{
	if(l == r){//叶子 
		tree[o] = wn[l];
		tree[o] %= mod;
		return ;
	}
	build(lson);
	build(rson);
	tree[o] = ( tree[o<<1] + tree[o<<1|1] ) % mod;//非叶子为其左右子树的和 
}

inline int query(int o,int l,int r,int L,int R)//查询 ：根、当前覆盖范围、查询范围 
{
	int res = 0;
	if(L <= l && R >= r){//当前覆盖范围小于查询范围 
		res += tree[o];//直接返回 
		return res % mod;
	} 
	else{//不在范围内 
		if(laz[o]){
			pushdown(o,len);//先更新当前层 
		}
		if(L <= mid){//向下层询问 
			res = (res + query(lson,L,R)) % mod;
		}
		if(R > mid){
			res = (res + query(rson,L,R)) % mod;
		}
	}
	return res % mod;
}



inline void update(int o,int l,int r,int L,int R,int x)//区间修改 ：根、当前覆盖范围、修改范围、修改值 
{
	if(L <= l && R >= r){ //覆盖范围在修改范围内 
		laz[o] += x;//更新lazy数组 
		tree[o] += x * len;//更新结点 
	}
	else{
		if(laz[o]){
			pushdown(o,len);//先下推当前层lazy 
		}
		if(L<=mid){//继续向下递归修改 
			update(lson,L,R,x);
		}
		if(R>mid){
			update(rson,L,R,x);
		}
		tree[o] = (tree[o<<1] + tree[o<<1|1]) % mod;//更新当前结点 
	}
}


/* ----------------------树链剖分及查询------------------------------------*/ 

inline void getSon(int x,int dad,int deep)//树链剖分 
{//当前结点，dad父亲，deep深度 
	dep[x] = deep;//标记每个点的深度 
	fa[x] = dad;//标记每个点的父亲 
	siz[x] = 1;//标记每个非叶子节点的子树大小 
	int mxson = -1;//记录重儿子的儿子数 
	for(inr i = head[x];~i;i = ed[i].ne){
		int y = ed[i].v;
		if(y == dad){
			continue ;
		}
		getSon(y,x,deep+1);
		siz[x] += siz[y];//把它的儿子数加到它身上 
		if(siz[y] > mxson){
			son[x] = y;//标记每个非叶子节点的重儿子编号 
			mxson = siz[y];
		}
	}
}

inline void dfs(int x,int topf)//按链的轻重重置结点编号 
{//x当前节点，topf当前链的最顶端的节点 
	id[x] = ++cnt;//标记每个点的新编号 
	wn[cnt] = wt[x];//把每个点的初始值赋到新编号上来
	top[x] = topf;//这个点所在链的顶端 
	if(!son[x]){//如果没有儿子则返回 
		return ;
	}
	dfs(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理
	for(inr i = head[x];~i;i = ed[i].ne){
		int y = ed[i].v;
		if(y == fa[x] || y == son[x]){
			continue;
		}
		dfs(y,y);//对于每一个轻儿子都有一条从它自己开始的链 
	}
}

inline int qRange(int x,int y)
{
	int ans = 0;
	while(top[x] != top[y]){//当两个点不在同一条链上 
		if(dep[top[x]] < dep[top[y]]){//把x点改为所在链顶端的深度更深的那个点
			swap(x,y);
		}			
		ans = (ans + query(1,1,n,id[top[x]],id[x])) % mod;//ans加上x点到x所在链顶端 这一段区间的点权和
		x = fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点
	}//直到两个点处于一条链上
	if(dep[x] > dep[y]){
		swap(x,y); //把x点看作深度更深的那个点
	}
	ans = (ans + query(1,1,n,id[x],id[y])) % mod;//这时再加上此时两个点的区间和即可
	return ans % mod;
}

inline void updRange(int x,int y,int k)//同上 
{
	k %= mod;
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]]){
			swap(x,y);
		}
		update(1,1,n,id[top[x]],id[x],k);
		x = fa[top[x]];
	}
	if(dep[x] > dep[y]){
		swap(x,y);
	}
	update(1,1,n,id[x],id[y],k);
}


inline int qSon(int x)
{
	return query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 
}

inline void updSon(int x,int k){ //同上 
	update(1,1,n,id[x],id[x]+siz[x]-1,k);
}

int main()
{
	n = read();m = read();rot = read();mod=read();
	init();
	for(inr i = 1;i<=n;i++){
		wt[i] = read();
	}
	for(inr i = 1,a,b;i<n;i++){
		a = read();b = read();
		addS(a,b);
	}
	getSon(rot,0,1);
	dfs(rot,rot);
	build(1,1,n);
	while(m--){
		int k,x,y,z;
		k = read();
		if(k == 1){
			x = read();y = read();z = read();
			updRange(x,y,z); 
		}
		else if(k == 2){
			x = read();y = read();
			printf("%d\n",qRange(x,y));
		}
		else if(k == 3){
			x = read();y = read();
			updSon(x,y);
		}
		else{
			x = read();
			printf("%d\n",qSon(x)); 
		} 
	}
	return 0;
}

```



## 六、动态规划

### 1.最长不严格单调子序列

#### （1）N^2算法（输出序列）

```c++
#include <iostream>
#include <algorithm>

using namespace std;
int pre[10]; //记录序列点的前一个节点 
int a[10],dp[10];//dp[]记录序列在当前节点的最优解（序列到这里最长能多长） 

void dfs(int pos) //输出最长上升序列 
{
    if(pos == -1)return;
    dfs(pre[pos]);
    cout << a[pos] << '\n';
}

int main()
{
	int n;
	int len = -1;
	cin >> n;
	for(int i = 1; i <= n; ++i)//初始化 
    {
	  	scanf("%d",&a[i]); 
        dp[i] = 1;//最短也是1（它自己） 
        pre[i] = -1;
    }
    int Max = -1, pos;//分别记录当前最长的序列长度和该序列的尾节点 
    for(int i = 1; i <= n; ++i) 
	{
		for(int j = 1; j < i; ++j)//从每个点的前面找 
        {
        	if(a[j] < a[i]) 
        	{
        	    if(dp[i] < dp[j] + 1)//如果有更优解 
                {
                    dp[i] = dp[j] + 1;//更新该点的最优解数组 
                    pre[i] = j;//父节点也要更新 
                    if(Max < dp[i])//看看该节点的最优解是不是目前最长的 
                    {
                        Max = dp[i];//如果是，记录一下 
                        pos = i;
                    }
                }
        	}
        }
        len = max(len, dp[i]);
	}
	dfs(pos);//由最长序列的尾节点向前找，并输出。 
	return 0;
}
```



#### （2）logN算法

```c++
//dilworth定理：一个序列中，最长单调子序列的个数等于其反义子列的长度（二子列概念互为补集） 
#include<bits/stdc++.h>
using namespace std;
int dp[50];
int dp2[50];
int a[50];
int len,len2;
int main()
{//此算法为时间复杂度为logn的算法特点是会生成一个序列长度与所求序列相同的伪序列 
	int n = 1; //所以无法输出序列，但是快 
	while(scanf("%d",&a[n])!=EOF)
	{
		getchar();
		n++;
	}
	dp[1] = a[1];  //初始化 
	len = 1;//长度一开始为一 
	dp2[1] = a[1];
	len2 = 1;
	for(int i = 2;i <n ;i++)
	{
		if (a[i]<=dp[len])
		{
			dp[++len] = a[i];//遇到比现在序列最小的还小的就可以加长序列的长度 
		} 
		else
		{
			int m = upper_bound(dp + 1, dp + len + 1, a[i],greater<int>()) - dp; 
			dp[m] = a[i];//greater 重定义（反转函数）找到比当前数小的数并替换他 
		}	//
	
		if (a[i]>dp2[len2])
		{
			dp2[++len2] = a[i];
		} 
		else
		{
			int p = lower_bound(dp2 + 1, dp2 + len2 + 1, a[i]) - dp2;
			dp2[p] = a[i];
		}		
	}
	printf("%d,%d\n",len,len2-1);
	return 0;
} 

```

### 2.区间DP

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 307;
const ll mod = 1000000007;

int w[maxn];
int s[maxn];//前缀和 
int dp[maxn][maxn];//区间最优解 

int main()//区间dp 
{
	int n;
	ios;
	cin>>n;
	for(int i = 1;i<=n;i++){
		cin>>w[i];
		s[i] = w[i] + s[i-1];
	}
	for(int len = 2;len<=n;len++){//枚举区间长度 
		for(int l = 1;l+len-1<=n;l++){
			int r = l+len-1;
			dp[l][r] = inf;
			for(int k = l;k<r;k++){//枚举区间中间的分点 
				dp[l][r] = min(dp[l][r],dp[l][k] + dp[k+1][r] + s[r]-s[l-1]);//细化区间 
			}
		}
	}
	cout<<dp[1][n]<<endl;
	return 0;
}
```

### 3.树形DP

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7

int sum[maxn],n;
ll dp[maxn];

struct node{
	int v,w;
};

vector<node>tree[maxn];

void dfs(int nw,int fa)//统计子树结点数以得出左右结点数，进而得出总路径长度和 
{
	sum[nw] = 1;
	for(int i = 0;i<tree[nw].size();i++){
		int son = tree[nw][i].v;
		ll len = tree[nw][i].w;
		if(son == fa){
			continue ;
		}
		dfs(son,nw);
		sum[nw] += sum[son];
		dp[nw] += dp[son] + (n - sum[son]) * sum[son] * len ;//各边使用次数即左节点数乘右结点数 
	}//树形DP从叶至根和树为一 
}


void init()
{
    for(int i = 0; i < n; i++)
    tree[i].clear();
    memset(dp,0,sizeof(dp));
	memset(sum,0,sizeof(sum));
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		init();
		for(int i = 1,u,v,w;i<n;i++){
			scanf("%d%d%d",&u,&v,&w);
			node nd;
			nd.v = v;nd.w = w;
			tree[u].push_back(nd);
			nd.v = u;
			tree[v].push_back(nd);
		}
		dfs(0,-1);
		printf("%f\n", (2.0 * dp[0] / n / (n-1)));
	}  
	return 0;
}
```

### 4.状压DP

```c++
//#include<bits/stdc++.h>
#include<cstdio>
#include<iostream>
#include<cmath>
#include<queue>
#include<vector>
#include<cstring>
#include<algorithm>
#include<map>
#include<set>
#include<stack>
#include<sstream>
#include<string>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 27;
const ll mod = 1000000007;//1e9+7

struct node{
	string na;
	int co,de;
}obj[maxn];

struct stats{
	int fa,ob,soc,tim;//存储状态 ：上一个状态，最新加入的学科序号，最低降分，总花费时间 
}dp[1<<15];//这里dp用2进制表示的是选一些书籍时的最优状态，如011100101011：1为被选0为还没被选 

int main()
{
	ios;
	int T,n;
	cin>>T;
	while(T--){
		cin>>n;
		memset(dp,0,sizeof(dp));
		for(int i = 0;i<n;i++){//注意必须从0开始存 
			cin>>obj[i].na>>obj[i].de>>obj[i].co;
		}
		int end = 1<<n;
		for(int i = 1;i<end;i++){//枚举所有状态 
			dp[i].soc = inf;
			for(int j = n-1;j>=0;j--){//要输出字典序最小的，所以倒着来（相同情况时最后字典序小的会顶掉大的） 
				int tmp = 1<<j;//二进制表示当前学科 
				if(tmp&i){// 如果这门学科是在当前状态的 （其实就是枚举当前状态涵盖的所有学科） 
					int pre = i - tmp;//没有该学科的上一状态（其实是由该学科决定的） 
					int ca =  dp[pre].tim + obj[j].co - obj[j].de;//扣掉的分数  ==写完前一门的时间 + 需要写的时间 - 要交的天数 
					if(ca < 0) ca = 0;//节约时间并不会加分，归零 
					if(ca+dp[pre].soc < dp[i].soc){//比较，找出扣分最少的，记录当前状态最优值 
						dp[i].fa = pre;
						dp[i].soc = dp[pre].soc + ca;
						dp[i].ob = j;
						dp[i].tim = dp[pre].tim + obj[j].co;
					}  
				}
			}
		}
		cout<<dp[end-1].soc<<endl;
		stack<int>sta;//因为是用类似链表的结构存储，用栈倒序输出 
		int tmp = end-1;
		while(dp[tmp].tim){
			sta.push(dp[tmp].ob);
			tmp = dp[tmp].fa;
		}
		while(!sta.empty()){
			tmp = sta.top();
			sta.pop();
			cout<<obj[tmp].na<<endl;
		}
	}
	return 0;
}
```



## 七、计算几何

```c++
* *#include
#include <math.h>
#include
#define eps 1e-8
#define zero(x) (((x)>0?(x):-(x))<eps)
#define pi acos(-1.0)
	struct point
{
	double x, y;
};
struct line
{
	point a, b;
};
struct point3
{
	double x, y, z;
};
struct line3
{
	point3 a, b;
};
struct plane3
{
	point3 a, b, c;
};
//计算cross product (P1-P0)x(P2-P0)
double xmult(point p1, point p2, point p0)
{
	return (p1.x - p0.x)(p2.y - p0.y) - (p2.x - p0.x)(p1.y - p0.y);
}
//计算dot product (P1-P0).(P2-P0)
double dmult(point p1, point p2, point p0)
{
	return (p1.x - p0.x)(p2.x - p0.x) + (p1.y - p0.y)(p2.y - p0.y);
}
//计算cross product U . V
point3 xmult(point3 u, point3 v)
{
	point3 ret;
	ret.x = u.yv.z - v.yu.z;
	ret.y = u.zv.x - u.xv.z;
	ret.z = u.xv.y - u.yv.x;
	return ret;
}
//计算dot product U . V
double dmult(point3 u, point3 v)
{
	return u.xv.x + u.yv.y + u.zv.z;
}
//两点距离
double distance(point p1, point p2)
{
	return sqrt((p1.x - p2.x)(p1.x - p2.x) + (p1.y - p2.y)(p1.y - p2.y));
}
//判三点共线
bool dots_inline(point p1, point p2, point p3)
{
	return zero(xmult(p1, p2, p3));
}
//判点是否在线段上,包括端点
bool dot_online_in(point p, line l)
{
	return zero(xmult(p, l.a, l.b)) && (l.a.x - p.x)(l.b.x - p.x) < eps && (l.a.y - p.y)(l.b.y - p.y) < eps;
}
//判点是否在线段上,不包括端点
bool dot_online_ex(point p, line l)
{
	return dot_online_in(p, l) && (!zero(p.x - l.a.x) || !zero(p.y - l.a.y)) && (!zero(p.x - l.b.x) || !zero(p.y - l.b.y));
}
//判两点在线段同侧,点在线段上返回0
bool same_side(point p1, point p2, line l)
{
	return xmult(l.a, p1, l.b) * xmult(l.a, p2, l.b) > eps;
}
//判两点在线段异侧,点在线段上返回0
bool opposite_side(point p1, point p2, line l)
{
	return xmult(l.a, p1, l.b) * xmult(l.a, p2, l.b) < -eps;
}
//判两直线平行
bool parallel(line u, line v)
{
	return zero((u.a.x - u.b.x)(v.a.y - v.b.y) - (v.a.x - v.b.x)(u.a.y - u.b.y));
}
//判两直线垂直
bool perpendicular(line u, line v)
{
	return zero((u.a.x - u.b.x)(v.a.x - v.b.x) + (u.a.y - u.b.y)(v.a.y - v.b.y));
}
//判两线段相交,包括端点和部分重合
bool intersect_in(line u, line v)
{
	if (!dots_inline(u.a, u.b, v.a) || !dots_inline(u.a, u.b, v.b))
		return !same_side(u.a, u.b, v) && !same_side(v.a, v.b, u);
	return dot_online_in(u.a, v) || dot_online_in(u.b, v) || dot_online_in(v.a, u) || dot_online_in(v.b, u);
}
//判两线段相交,不包括端点和部分重合
bool intersect_ex(line u, line v)
{
	return opposite_side(u.a, u.b, v) && opposite_side(v.a, v.b, u);
}
//计算两直线交点,注意事先判断直线是否平行!
//线段交点请另外判线段相交(同时还是要判断是否平行!)
point intersection(line u, line v)
{
	point ret = u.a;
	double t = ((u.a.x - v.a.x)(v.a.y - v.b.y) - (u.a.y - v.a.y)(v.a.x - v.b.x)) / ((u.a.x - u.b.x)(v.a.y - v.b.y) - (u.a.y - u.b.y)(v.a.x - v.b.x));
	ret.x += (u.b.x - u.a.x)t;
	ret.y += (u.b.y - u.a.y)t;
	return ret;
}
point intersection(point u1, point u2, point v1, point v2)
{
	point ret = u1;
	double t = ((u1.x - v1.x)(v1.y - v2.y) - (u1.y - v1.y)(v1.x - v2.x)) / ((u1.x - u2.x)(v1.y - v2.y) - (u1.y - u2.y)(v1.x - v2.x));
	ret.x += (u2.x - u1.x) * t;
	ret.y += (u2.y - u1.y) * t;
	return ret;
}
//点到直线上的最近点
point ptoline(point p, line l)
{
	point t = p;
	t.x += l.a.y - l.b.y, t.y += l.b.x - l.a.x;
	return intersection(p, t, l.a, l.b);
}
//点到直线距离
double disptoline(point p, line l)
{
	return fabs(xmult(p, l.a, l.b)) / distance(l.a, l.b);
}
//点到线段上的最近点
point ptoseg(point p, line l)
{
	point t = p;
	t.x += l.a.y - l.b.y, t.y += l.b.x - l.a.x;
	if (xmult(l.a, t, p)xmult(l.b, t, p) > eps)
		return distance(p, l.a) < distance(p, l.b) ? l.a : l.b;
	return intersection(p, t, l.a, l.b);
}
//点到线段距离
double disptoseg(point p, line l)
{
	point t = p;
	t.x += l.a.y - l.b.y, t.y += l.b.x - l.a.x;
	if (xmult(l.a, t, p)xmult(l.b, t, p) > eps)
		return distance(p, l.a) < distance(p, l.b) ? distance(p, l.a) : distance(p, l.b);
	return fabs(xmult(p, l.a, l.b)) / distance(l.a, l.b);
}
//矢量V 以P 为顶点逆时针旋转angle 并放大scale 倍
point rotate(point v, point p, double angle, double scale)
{
	point ret = p;
	v.x -= p.x, v.y -= p.y;
	p.x = scalecos(angle);
	p.y = scalesin(angle);
	ret.x += v.xp.x - v.yp.y;
	ret.y += v.xp.y + v.yp.x;
	return ret;
}
//计算三角形面积,输入三顶点
double area_triangle(point p1, point p2, point p3)
{
	return fabs(xmult(p1, p2, p3)) / 2;
}
//计算三角形面积,输入三边长
double area_triangle(double a, double b, double c)
{
	double s = (a + b + c) / 2;
	return sqrt(s(s - a)(s - b)(s - c));
}
//计算多边形面积,顶点按顺时针或逆时针给出
double area_polygon(int n, point p)
{
	double s1 = 0, s2 = 0;
	int i;
	for (i = 0; i < n; i++)
		s1 += p[(i + 1) % n].yp[i].x, s2 += p[(i + 1) % n].yp[(i + 2) % n].x;
	return fabs(s1 - s2) / 2;
}
//计算圆心角lat 表示纬度,-90<=w<=90,lng 表示经度
//返回两点所在大圆劣弧对应圆心角,0<=angle<=pi
double angle(double lng1, double lat1, double lng2, double lat2)
{
	double dlng = fabs(lng1 - lng2) * pi / 180;
	while (dlng >= pi + pi)
		dlng -= pi + pi;
	if (dlng > pi)
		dlng = pi + pi - dlng;
	lat1 *= pi / 180, lat2 *= pi / 180;
	return acos(cos(lat1) * cos(lat2) * cos(dlng) + sin(lat1)sin(lat2));
}
//计算距离,r 为球半径
double line_dist(double r, double lng1, double lat1, double lng2, double lat2)
{
	double dlng = fabs(lng1 - lng2)pi / 180;
	while (dlng >= pi + pi)
		dlng -= pi + pi;
	if (dlng > pi)
		dlng = pi + pi - dlng;
	lat1 = pi / 180, lat2 = pi / 180;
	return rsqrt(2 - 2 * (cos(lat1)cos(lat2)cos(dlng) + sin(lat1)sin(lat2)));
}
//计算球面距离,r 为球半径
inline double sphere_dist(double r, double lng1, double lat1, double lng2, double lat2)
{
	return rangle(lng1, lat1, lng2, lat2);
}
//外心
point circumcenter(point a, point b, point c)
{
	line u, v;
	u.a.x = (a.x + b.x) / 2;
	u.a.y = (a.y + b.y) / 2;
	u.b.x = u.a.x - a.y + b.y;
	u.b.y = u.a.y + a.x - b.x;
	v.a.x = (a.x + c.x) / 2;
	v.a.y = (a.y + c.y) / 2;
	v.b.x = v.a.x - a.y + c.y;
	v.b.y = v.a.y + a.x - c.x;
	return intersection(u, v);
}
//内心
point incenter(point a, point b, point c)
{
	line u, v;
	double m, n;
	u.a = a;
	m = atan2(b.y - a.y, b.x - a.x);
	n = atan2(c.y - a.y, c.x - a.x);
	u.b.x = u.a.x + cos((m + n) / 2);
	u.b.y = u.a.y + sin((m + n) / 2);
	v.a = b;
	m = atan2(a.y - b.y, a.x - b.x);
	n = atan2(c.y - b.y, c.x - b.x);
	v.b.x = v.a.x + cos((m + n) / 2);
	v.b.y = v.a.y + sin((m + n) / 2);
	return intersection(u, v);
}
//垂心
point perpencenter(point a, point b, point c)
{
	line u, v;
	u.a = c;
	u.b.x = u.a.x - a.y + b.y;
	u.b.y = u.a.y + a.x - b.x;
	v.a = b;
	v.b.x = v.a.x - a.y + c.y;
	v.b.y = v.a.y + a.x - c.x;
	return intersection(u, v);
}
//重心
//到三角形三顶点距离的平方和最小的点
//三角形内到三边距离之积最大的点
point barycenter(point a, point b, point c)
{
	line u, v;
	u.a.x = (a.x + b.x) / 2;
	u.a.y = (a.y + b.y) / 2;
	u.b = c;
	v.a.x = (a.x + c.x) / 2;
	v.a.y = (a.y + c.y) / 2;
	v.b = b;
	return intersection(u, v);
}
//费马点
//到三角形三顶点距离之和最小的点
point fermentpoint(point a, point b, point c)
{
	point u, v;
	double step = fabs(a.x) + fabs(a.y) + fabs(b.x) + fabs(b.y) + fabs(c.x) + fabs(c.y);
	int i, j, k;
	u.x = (a.x + b.x + c.x) / 3;
	u.y = (a.y + b.y + c.y) / 3;
	while (step > 1e-10)
	{
		for (k = 0; k < 10; step /= 2, k++)
		{
			for (i = -1; i <= 1; i++)
			{
				for (j = -1; j <= 1; j++)
				{
					v.x = u.x + stepi;
					v.y = u.y + stepj;
					if (distance(u, a) + distance(u, b) + distance(u, c) > distance(v, a) + distance(v, b) + distance(v, c))
					{
						u = v;
					}
				}
			}
		}
	}
	return u;
}
//矢量差 U - V
point3 subt(point3 u, point3 v)
{
	point3 ret;
	ret.x = u.x - v.x;
	ret.y = u.y - v.y;
	ret.z = u.z - v.z;
	return ret;
}
///三维///
//取平面法向量
point3 pvec(plane3 s)
{
	return xmult(subt(s.a, s.b), subt(s.b, s.c));
}
point3 pvec(point3 s1, point3 s2, point3 s3)
{
	return xmult(subt(s1, s2), subt(s2, s3));
}
//两点距离,单参数取向量大小
double distance(point3 p1, point3 p2)
{
	return sqrt((p1.x - p2.x)(p1.x - p2.x) + (p1.y - p2.y)(p1.y - p2.y) + (p1.z - p2.z)(p1.z - p2.z));
}
//向量大小
double vlen(point3 p)
{
	return sqrt(p.xp.x + p.yp.y + p.zp.z);
}
//判三点共线
bool dots_inline(point3 p1, point3 p2, point3 p3)
{
	return vlen(xmult(subt(p1, p2), subt(p2, p3))) < eps;
}
//判四点共面
bool dots_onplane(point3 a, point3 b, point3 c, point3 d)
{
	return zero(dmult(pvec(a, b, c), subt(d, a)));
}
//判点是否在线段上,包括端点和共线
bool dot_online_in(point3 p, line3 l)
{
	return zero(vlen(xmult(subt(p, l.a), subt(p, l.b)))) && (l.a.x - p.x)(l.b.x - p.x) < eps && (l.a.y - p.y)(l.b.y - p.y) < eps && (l.a.z - p.z)(l.b.z - p.z) < eps;
}
//判点是否在线段上,不包括端点
bool dot_online_ex(point3 p, line3 l)
{
	return dot_online_in(p, l) && (!zero(p.x - l.a.x) || !zero(p.y - l.a.y) || !zero(p.z - l.a.z)) && (!zero(p.x - l.b.x) || !zero(p.y - l.b.y) || !zero(p.z - l.b.z));
}
//判点是否在空间三角形上,包括边界,三点共线无意义
bool dot_inplane_in(point3 p, plane3 s)
{
	return zero(vlen(xmult(subt(s.a, s.b), subt(s.a, s.c))) - vlen(xmult(subt(p, s.a), subt(p, s.b))) - vlen(xmult(subt(p, s.b), subt(p, s.c))) - vlen(xmult(subt(p, s.c), subt(p, s.a))));
}
//判点是否在空间三角形上,不包括边界,三点共线无意义
bool dot_inplane_ex(point3 p, plane3 s)
{
	return dot_inplane_in(p, s) && vlen(xmult(subt(p, s.a), subt(p, s.b))) > eps && vlen(xmult(subt(p, s.b), subt(p, s.c))) > eps && vlen(xmult(subt(p, s.c), subt(p, s.a))) > eps;
}
//判两点在线段同侧,点在线段上返回0,不共面无意义
bool same_side(point3 p1, point3 p2, line3 l)
{
	return dmult(xmult(subt(l.a, l.b), subt(p1, l.b)), xmult(subt(l.a, l.b), subt(p2, l.b))) > eps;
}
//判两点在线段异侧,点在线段上返回0,不共面无意义
bool opposite_side(point3 p1, point3 p2, line3 l)
{
	return dmult(xmult(subt(l.a, l.b), subt(p1, l.b)), xmult(subt(l.a, l.b), subt(p2, l.b))) < -eps;
}
//判两点在平面同侧,点在平面上返回0
bool same_side(point3 p1, point3 p2, plane3 s)
{
	return dmult(pvec(s), subt(p1, s.a))dmult(pvec(s), subt(p2, s.a)) > eps;
}
bool same_side(point3 p1, point3 p2, point3 s1, point3 s2, point3 s3)
{
	return dmult(pvec(s1, s2, s3), subt(p1, s1))dmult(pvec(s1, s2, s3), subt(p2, s1)) > eps;
}
//判两点在平面异侧,点在平面上返回0
bool opposite_side(point3 p1, point3 p2, plane3 s)
{
	return dmult(pvec(s), subt(p1, s.a))dmult(pvec(s), subt(p2, s.a)) < -eps;
}
bool opposite_side(point3 p1, point3 p2, point3 s1, point3 s2, point3 s3)
{
	return dmult(pvec(s1, s2, s3), subt(p1, s1))dmult(pvec(s1, s2, s3), subt(p2, s1)) < -eps;
}
//判两直线平行
bool parallel(line3 u, line3 v)
{
	return vlen(xmult(subt(u.a, u.b), subt(v.a, v.b))) < eps;
}
//判两平面平行
bool parallel(plane3 u, plane3 v)
{
	return vlen(xmult(pvec(u), pvec(v))) < eps;
}
//判直线与平面平行
bool parallel(line3 l, plane3 s)
{
	return zero(dmult(subt(l.a, l.b), pvec(s)));
}
bool parallel(point3 l1, point3 l2, point3 s1, point3 s2, point3 s3)
{
	return zero(dmult(subt(l1, l2), pvec(s1, s2, s3)));
}
//判两直线垂直
bool perpendicular(line3 u, line3 v)
{
	return zero(dmult(subt(u.a, u.b), subt(v.a, v.b)));
}
//判两平面垂直
bool perpendicular(plane3 u, plane3 v)
{
	return zero(dmult(pvec(u), pvec(v)));
}
//判直线与平面平行
bool perpendicular(line3 l, plane3 s)
{
	return vlen(xmult(subt(l.a, l.b), pvec(s))) < eps;
}
//判两线段相交,包括端点和部分重合
bool intersect_in(line3 u, line3 v)
{
	if (!dots_onplane(u.a, u.b, v.a, v.b))
		return 0;
	if (!dots_inline(u.a, u.b, v.a) || !dots_inline(u.a, u.b, v.b))
		return !same_side(u.a, u.b, v) && !same_side(v.a, v.b, u);
	return dot_online_in(u.a, v) || dot_online_in(u.b, v) || dot_online_in(v.a, u) || dot_online_in(v.b, u);
}
//判两线段相交,不包括端点和部分重合
bool intersect_ex(line3 u, line3 v)
{
	return dots_onplane(u.a, u.b, v.a, v.b) && opposite_side(u.a, u.b, v) && opposite_side(v.a, v.b, u);
}
//判线段与空间三角形相交,包括交于边界和(部分)包含
bool intersect_in(line3 l, plane3 s)
{
	return !same_side(l.a, l.b, s) && !same_side(s.a, s.b, l.a, l.b, s.c) && !same_side(s.b, s.c, l.a, l.b, s.a) && !same_side(s.c, s.a, l.a, l.b, s.b);
}
//判线段与空间三角形相交,不包括交于边界和(部分)包含
bool intersect_ex(line3 l, plane3 s)
{
	return opposite_side(l.a, l.b, s) && opposite_side(s.a, s.b, l.a, l.b, s.c) && opposite_side(s.b, s.c, l.a, l.b, s.a) && opposite_side(s.c, s.a, l.a, l.b, s.b);
}
//计算两直线交点,注意事先判断直线是否共面和平行!
//线段交点请另外判线段相交(同时还是要判断是否平行!)
point3 intersection(line3 u, line3 v)
{
	point3 ret = u.a;
	double t = ((u.a.x - v.a.x)(v.a.y - v.b.y) - (u.a.y - v.a.y)(v.a.x - v.b.x))
		/ ((u.a.x - u.b.x)(v.a.y - v.b.y) - (u.a.y - u.b.y)(v.a.x - v.b.x));
	ret.x += (u.b.x - u.a.x)t;
	ret.y += (u.b.y - u.a.y)t;
	ret.z += (u.b.z - u.a.z)t;
	return ret;
}
//计算直线与平面交点,注意事先判断是否平行,并保证三点不共线!
//线段和空间三角形交点请另外判断
point3 intersection(line3 l, plane3 s)
{
	point3 ret = pvec(s);
	double t = (ret.x(s.a.x - l.a.x) + ret.y(s.a.y - l.a.y) + ret.z(s.a.z - l.a.z)) / (ret.x(l.b.x - l.a.x) + ret.y(l.b.y - l.a.y) + ret.z(l.b.z - l.a.z));
	ret.x = l.a.x + (l.b.x - l.a.x)t;
	ret.y = l.a.y + (l.b.y - l.a.y)t;
	ret.z = l.a.z + (l.b.z - l.a.z)t;
	return ret;
}
point3 intersection(point3 l1, point3 l2, point3 s1, point3 s2, point3 s3)
{
	point3 ret = pvec(s1, s2, s3);
	double t = (ret.x(s1.x - l1.x) + ret.y(s1.y - l1.y) + ret.z(s1.z - l1.z)) /
		(ret.x(l2.x - l1.x) + ret.y(l2.y - l1.y) + ret.z(l2.z - l1.z));
	ret.x = l1.x + (l2.x - l1.x) * t;
	ret.y = l1.y + (l2.y - l1.y) * t;
	ret.z = l1.z + (l2.z - l1.z)t;
	return ret;
}
//计算两平面交线,注意事先判断是否平行,并保证三点不共线!
line3 intersection(plane3 u, plane3 v)
{
	line3 ret;
	ret.a = parallel(v.a, v.b, u.a, u.b, u.c) ? intersection(v.b, v.c, u.a, u.b, u.c) : intersection(v.a, v.b, u.a, u.b, u.c);
	ret.b = parallel(v.c, v.a, u.a, u.b, u.c) ? intersection(v.b, v.c, u.a, u.b, u.c) : intersection(v.c, v.a, u.a, u.b, u.c);
	return ret;
}
line3 intersection(point3 u1, point3 u2, point3 u3, point3 v1, point3 v2, point3 v3)
{
	line3 ret;
	ret.a = parallel(v1, v2, u1, u2, u3) ? intersection(v2, v3, u1, u2, u3) : intersection(v1, v2, u1, u2, u3);
	ret.b = parallel(v3, v1, u1, u2, u3) ? intersection(v2, v3, u1, u2, u3) : intersection(v3, v1, u1, u2, u3);
	return ret;
}
//点到直线距离
double ptoline(point3 p, line3 l)
{
	return vlen(xmult(subt(p, l.a), subt(l.b, l.a))) / distance(l.a, l.b);
}
//点到平面距离
double ptoplane(point3 p, plane3 s)
{
	return fabs(dmult(pvec(s), subt(p, s.a))) / vlen(pvec(s));
}
//直线到直线距离
double linetoline(line3 u, line3 v)
{
	point3 n = xmult(subt(u.a, u.b), subt(v.a, v.b));
	return fabs(dmult(subt(u.a, v.a), n)) / vlen(n);
}
//两直线夹角cos 值
double angle_cos(line3 u, line3 v)
{
	return dmult(subt(u.a, u.b), subt(v.a, v.b)) / vlen(subt(u.a, u.b)) / vlen(subt(v.a, v.b));
}
//两平面夹角cos 值
double angle_cos(plane3 u, plane3 v)
{
	return dmult(pvec(u), pvec(v)) / vlen(pvec(u)) / vlen(pvec(v));
}
//直线平面夹角sin 值
double angle_sin(line3 l, plane3 s)
{
	return dmult(subt(l.a, l.b), pvec(s)) / vlen(subt(l.a, l.b)) / vlen(pvec(s));
}
//凸包
int ConvexHull(point p, int n, point ch)//Andrew
{
	int m = 0;
	for (int i = 0; i < n; i++)
	{
		while (m > 1 && Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) <= 0) m–;
		//如果发现更好的点把之前凸包内的点吐出
		ch[m++] = p[i];
	}
	int k = m;
	for (int i = n - 2; i >= 0; i–)
	{
		while (m > k && Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) <= 0) m–;
		ch[m++] = p[i];
	}
	if (n > 1)
		m–;
	return m;
}
叉积为负 点在线段的左侧
叉积为正 点在线段的右侧
先用凸包找到最大的多边形然后再计算多边形面积
计算多边形面积使点按逆时针或顺时针排序
```



### 1.求重心

​		/**/重心的公式：x = (w1*x1+w2*x2...+wn*xn) / n，wi是权重，xi是到y轴的距离。**

### 2.两圆交面积

```c++
struct cri{
	int x;
	int y;
	double r;
	double are;
}mp[maxn];

int n;

double AREA(cri a,cri b)
{
	double d = sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
	if (d >= a.r+b.r)
		return 0;
	if (a.r>b.r)
	{
		double tmp = a.r;
		a.r = b.r;
		b.r = tmp;
	}
	if(b.r - a.r >= d)
		return pi*a.r*a.r;
	double ang1=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));
	double ang2=acos((b.r*b.r+d*d-a.r*a.r)/(2*b.r*d));
	return ang1*a.r*a.r + ang2*b.r*b.r - a.r*d*sin(ang1);
}
```

### 3.点与直线关系

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7
/* 
在两个给定的查询点之间绘制一条线段。如果这条线段与之相交的直线
的数量是偶数，那么答案是"same"，如果是奇数，那么答案是"different"。
这样问题便可以转化为求两点是否在一条直线左右侧，这可以通过叉积
判断两点是否在直线同侧求出
//叉积：向量积
定义：平面上的三点P1(x1,y1),P2(x2,y2),P3(x3,y3)的面积量：
S(P1,P2,P3)=|y1 y2 y3|= (x1-x3)*(y2-y3)-(y1-y3)*(x2-x3) 
当P1P2P3逆时针时S为正的，当P1P2P3顺时针时S为负的。 
令矢量的起点为A，终点为B，判断的点为C， 
如果S（A，B，C）为正数，则C在矢量AB的左侧； 
如果S（A，B，C）为负数，则C在矢量AB的右侧； 
如果S（A，B，C）为0，则C在直线AB上。
 
*/
struct line{
	int x1;
	int x2;
	int y1;
	int y2;
}mp[maxn];

int main()
{
	ios;
	int n,m;
	cin>>n;
	for(int i = 1;i<=n;i++){
		cin>>mp[i].x1>>mp[i].y1>>mp[i].x2>>mp[i].y2;
	}
	cin>>m;
	int x3,y3,x4,y4;
	for(int i = 1;i<=m;i++){
		cin>>x3>>y3>>x4>>y4;
		bool flag = true;
		for(int j = 1;j<=n;j++){//连续异或累计穿越直线是奇数还是偶数 
			flag = flag ^ ((mp[j].x2 - mp[j].x1) * (y4 - mp[j].y1) - (mp[j].y2 - mp[j].y1) * (x4 - mp[j].x1) < 0)
					^ ((mp[j].x2 - mp[j].x1) * (y3 - mp[j].y1) - (mp[j].y2 - mp[j].y1) * (x3 - mp[j].x1) < 0);			
		}
		if(flag) cout<<"same"<<endl;
		else cout<<"different"<<endl;			
	}

	return 0;
} 
```

### 4.最优三角剖分

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 55; 
const ll mod = 1000000007;//1e9+7

struct node{
	double x,y;
}ve[maxn];

int n;
double dp[maxn][maxn];

double area(node a,node b,node c)
{
	return fabs((b.x-a.x) * (c.y-a.y) - (c.x-a.x) * (b.y-a.y)) / 2.0;
}

bool judge(int a,int b,int c)
{
	for(int i = 1;i<=n;i++){
		if( a == i || b == i || c == i) continue ;
		double s = area(ve[i],ve[a],ve[b]) + area(ve[i],ve[b],ve[c]) + area(ve[i],ve[a],ve[c]);
		if(s-area(ve[a],ve[b],ve[c])<eps) return true ;
	}
	return false ;
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i = 1;i<=n;i++){
			scanf("%lf%lf",&ve[i].x,&ve[i].y);
		}
		memset(dp,0,sizeof(dp));
		for(int len = 2;len<=n;len++){
			for(int l = 1;l<=n-len;l++){
				int r = l + len;
				dp[l][r] = inf;
				for(int k = l+1;k<=r-1;k++){
					if(judge(l,k,r)) continue ;
					dp[l][r] = min(dp[l][r],max(area(ve[l],ve[k],ve[r]),max(dp[l][k],dp[k][r])));
				}
			}
		}
		printf("%.1f\n",dp[1][n]);
	}
	return 0;
}
```



## 八、字符串

### 1.KMP

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 1000007;
const ll mod = 1000000007;

int n,m;//n:主串长度 m：子串长度
char mst[maxn];
char sst[maxn];
int Next[maxn];

void getNext()//构建Next数组:存储以当前字符结尾的最长前缀长度//注意Next不大写有CE风险 
{//i：后缀指针，j:前缀指针 
	for(int i = 1,j = 0;i<m;i++){//O(m) 
		while(j > 0 && sst[j] != sst[i]){//当前字符与前缀末字符不相同时 
			j = Next[j-1];//前缀指针前跳 
		}
		if(sst[j] == sst[i]){//相同时前后缀指针后移 
			Next[i] = ++j;
		}
	}//j==0两指针不相容时，就默认为零 
}

int kmp()
{
	int res = 0;
	for(int i = 0,j = 0;i<n;){//KMP：i：主串指针 ；j:子串指针 O(n)
		if(mst[i] == sst[j]){
			i++,j++;
			if(j != m) continue ;
			res++;	//当匹配到头时，就可以记录 
		}
		j = Next[j-1];//可重叠的连续匹配时，匹配完全成功和失败后操作一样，j往前跳 
		if( mst[i] != sst[j]) i++;			
	}
	return res;	
}

int main()
{
	ios;
	int T;
	cin>>T;
	while(T--){
		cin>>sst>>mst;
		n = strlen(mst);
		m = strlen(sst);
		getNext();
		cout<<kmp()<<endl;	
	}
	return 0;
}
```

### 2.扩展KMP

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 100007;//1e5+7 
const ll mod = 1000000007;//1e9+7

int Next[maxn];//代表模式串各子串（以当前开头）(后缀)与原串的最长公共前缀 （长度） 
int extend[maxn]; // 代表主串各子串（以当前开头）（后缀）与模式串的最长公共前缀 （长度）

void getNext(char *str)//这里方法与kmp有所不同 
{//这里的方法和得到extend数组的方法相同，不过是把模式串当主串和自己匹配公共前缀 
	int i,j,len = strlen(str);
	Next[0] = len;//Next[0]就是原串 
	while(str[i] == str[i+1] && i+1<len) i++;//先将Next[1]初始化 
	Next[1] = i; //目前遍历到的最远位置 
	int po = 1; //最远的那个的起始位置 
	for(i = 2;i<=len;i++){//从二开始遍历 
		if(Next[i-po] + i < Next[po] + po){ //如果当下的位置的子串与本串的公共前缀的长度在当前位置的基础上没有超过现在已经遍历到的位置 
			Next[i] = Next[i-po];//说明当前串与主串的匹配数据和其与本串的匹配数据是一样的（因为本串和主串到那里是完全一样的） 
		}//直接更新即可 
		else{
			j = Next[po] + po - i;//如果超出了目前最大匹配长度，就接着往后遍历 
			if(j < 0) j = 0;//如果i>extend[po]+po则要从头开始匹配
			while(i+j < len && str[j] == str[j+i]) j++;
			Next[i] = j;
			po = i;//更新最远的起始位置 
		}
	}
}

void getExtend(char *s1,char *s2)//方法同上 
{
	int i = 0,po = 0,j,len1 = strlen(s1),len2 = strlen(s2);
	getNext(s2);
	while(s1[i] == s2[i] && i < len2 && i<len1) i++;
	extend[0] = i;
	for(i = 1;i<len1;i++){
		if(Next[i-po] + i < extend[po] + po){
			extend[i] = Next[i - po];
		}
		else{
			j = extend[po] + po - i;
			if(j < 0) j = 0;
			while( i + j < len1 && j < len2 && s1[j + i] == s2[j]) j++;
			extend[i] = j;
			po = i;	
		}
	}
}

char T[maxn],P[maxn];//主串与模式串 

int main()
{
	while(~scanf("%s%s",T,P)){
		getExtend(P,T);
		int len = strlen(P);
		int mx = 0,mxi = 0,flag = 0;
		for(int i = 0;i<len;i++){
			if(extend[i] > mx && extend[i] + i == len){//遍历，求最大值 
				mx = extend[i];
				mxi = i;
			}
		}
		if(mx) printf("%s %d\n",P+mxi,mx);
		else printf("%d\n",0);
	}
	return 0;
}

```

### 3.字典树

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
const ll mod = 1000000007;//1e9+7

//对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树
//很多题都是要用到节点下标来表示某个字符串
const int maxn =2e6+5;//如果是64MB可以开到2e6+5，尽量开大
int tree[maxn][30];//tree[i][j]表示节点i的第j个儿子的节点编号
bool flagg[maxn];//表示以该节点结尾是一个单词
int tot;//总节点数
void insert_(string str)
{
   int  len=str.length();
   int root=0;
   for(int i=0;i<len;i++)
   {
       int id=str[i]-'a';
       if(!tree[root][id]) tree[root][id]=++tot;
       root=tree[root][id];
   }
   flagg[root]=true;
}
bool find_(string str)//查询操作，按具体要求改动
{
    int len=str.length();
    int root=0;
    for(int i=0;i<len;i++)
    {
        int id=str[i]-'a';
        if(!tree[root][id]) return true;
        root=tree[root][id];
    }
    if(flagg[root]) return false;//已被记录的不再返回 
    return true;
}
void init()//最后清空，节省时间
{
    for(int i=0;i<=tot;i++)
    {
       flagg[i]=false;
       for(int j=0;j<10;j++)
           tree[i][j]=0;
    }
   tot=0;//RE有可能是这里的问题
}

string st,tmp;

int main()
{
	ios;
	while(getline(cin,st)){//先整行读入 
		init();
		if(st == "#") break ;
		int ans = 0;
		stringstream io(st);
		while(io>>tmp){//再逐个读入 
			if(find_(tmp)){
				ans++;
				insert_(tmp);
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

### 4.AC自动机

```c++
#include <queue>
#include <cstdlib>
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 550007;//1e5+7 
const ll mod = 1000000007;//1e9+7

int cnt; 
int trie[maxn][50];//字典树//tire[now][i] -> 下一个字母为i+'a'的节点的下标为tire[now][i]
int cntword[maxn];//记录该单词出现次数
int fail[maxn];//失败时的回溯指针//fail[now]    ->当前节点now的失败指针指向的地方

void init()
{
	cnt = 0;
	memset(trie,0,sizeof(trie));
	memset(cntword,0,sizeof(cntword));
	memset(fail,0,sizeof(fail)); 
}

void insert_words(string str)//构建字典树 
{
	int root = 0;
	for(int i = 0;i<str.size();i++){
		int next = str[i] - 'a';
		if(!trie[root][next]){
			trie[root][next] = ++cnt;
		}
		root = trie[root][next];
	}
	cntword[root]++;//当前节点单词数+1
}

void build_fail()//BFS构建fail指针 
{
	fail[0] = 0;
	queue<int>q;
	for(int i = 0;i<26;i++){
		if(trie[0][i]){//将第二层所有出现了的字母扔进队列
			fail[trie[0][i]] = 0;// 第一层直接指向根节点 
			q.push(trie[0][i]);
		}
	}
	while(!q.empty()){//逐层遍历 
		int nw = q.front();
		q.pop();
		for(int i = 0;i<26;i++){//查询26个字母
			if(trie[nw][i]){//若含有该子结点 
				fail[trie[nw][i]] = trie[fail[nw]][i];//子结点fail指向他爸（nw）的fail指向结点的相应子结点 
				q.push(trie[nw][i]);//下一层入队 
			}
			else{//没有该子结点构建这个结点指向本结点（nw）的fail指针指向结点的相应子结点 
				trie[nw][i] = trie[fail[nw]][i];//逐层完善找到最长后缀，即在失配后快速跳转到最长后缀处 
			}//  fail初始化为0,也就是说,如果fail指针有指向的话则指向xxxxx,否则其实就相当于 `trie[now][i] = trie[0][i]`;而tire[0]其实就是根
		}
	}
}

int query(string str)//查询待匹配串包含多少模式串 
{
	int nw = 0,ans = 0;
	for(int i = 0;i<str.size();i++){//遍历文本串
		nw = trie[nw][str[i] - 'a'];//从s[i]点开始寻找
		for(int j = nw;j && ~cntword[j];j = fail[j]){//一直向下寻找,直到匹配失败(失败指针指向根或者当前节点已找过).
			ans += cntword[j];
			cntword[j] = -1;//将遍历国后的节点标记,防止重复计算
		}
	}
	return ans;
}

string st;

int main()
{
	ios;
	int T,n;
	cin>>T;
	while(T--){
		cin>>n;
		init();
		for(int i = 1;i<=n;i++){
			cin>>st;
			insert_words(st);
		}
		build_fail();
		cin>>st;
		cout<<query(st)<<endl;	
	}
	return 0;
}
```

### 5.马拉车

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int maxn = 1e6 + 5;
char s[maxn * 2], str[maxn * 2];
int Len[maxn * 2], len;
void getstr() {//重定义字符串
	int k = 0;
	str[k++] = '@';//开头加个特殊字符防止越界
	for (int i = 0; i < len; i++) {
		str[k++] = '#';
		str[k++] = s[i];
	}
	str[k++] = '#';
	len = k;
	str[k] = 0;//字符串尾设置为0，防止越界
}
int manacher() {
	int mx = 0, id;//mx为最右边，id为中心点
	int maxx = 0;
	for (int i = 1; i < len; i++) {
		if (mx > i) Len[i] = min(mx - i, Len[2 * id - i]);//判断当前点超没超过mx
		else Len[i] = 1;//超过了就让他等于1，之后再进行查找
		while (str[i + Len[i]] == str[i - Len[i]]) Len[i]++;//判断当前点是不是最长回文子串，不断的向右扩展
		if (Len[i] + i > mx) {//更新mx
			mx = Len[i] + i;
			id = i;//更新中间点
			maxx = max(maxx, Len[i]);//最长回文字串长度
		}
	}
	return (maxx - 1);
}
int main() {
	while(~scanf("%s", s)){
		memset(str,'\0',sizeof(str));
		memset(Len,0,sizeof(Len));
		len = strlen(s);
		getstr();
		printf("%d\n",manacher());		
	}
	return 0;
}

```

### 6.Hash

```c++
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define debug(a) cout << #a << " " << a << endl
using namespace std;
typedef long long ll;
typedef unsigned long long ull;//无符号整数有自动取模的效果 
const double pi=acos(-1);
const double eps = 1e-8;
const int inf = 0x3f3f3f3f;
const int maxn = 50007;
const ll mod = 1000000007;//1e9+7

string st;
int len;
ull p = 23333;//确定基数 
ull hashe[maxn];//存储hashe前缀和 
ull base[maxn];//存粹每一位对应的基数倍数便于计算 

void fbase()//建立基数数组 
{
	base[0] = 1;
	for(int i = 1;i<maxn;i++){
		base[i] = base[i-1] * p;
	}
}

void Hash()//建立哈希数组
{
	hashe[len] = 0;
	for(int i = len-1;i>=0;i--){
		hashe[i] = hashe[i+1]*p+(st[i] - 'a');
	}
}

ull query(int l,int r)//返回区间子串hashe 
{
	return hashe[l] - hashe[r+1] * base[r-l+1];
}

int m; 

int slove(int le)
{
	map<ull,ull>mp;//存储hashe与对应出现次数 
	int res = -1;
	for(int i = 0;i<=len-le;i++){//遍历字符串 
		ull t = query(i,i+le-1);
		mp[t]++;
		if(mp[t] >= m){
			res = i;
		}
	}
	return res;
}

int main()
{
	ios;
	fbase();
	while(cin>>m && m){
		cin>>st;
		len = st.length(); 
		Hash();
		int l = 1,r = len - m + 1,t,ans;//二分枚举长度 
		if(slove(l) == -1){
			cout<<"none"<<endl;
			continue ;
		}
		while(l <= r){
			int mid = (l + r) >> 1;
			t = slove(mid);
			if(~t){
				l = mid + 1;
				ans = t; 
			}
			else{
				r = mid - 1;
			}
		} 
		cout<<r<<' '<<ans<<endl;
	}
	return 0;
}
```



## 九、博弈论

### 1.巴什博弈（Bash Game）

  一堆n个物品，两个人轮流从中取出1~m个，最后取光者胜（不能继续取的人输）。

  同余定理：n=k∗(m+1)+rn=k∗(m+1)+r，先者拿走rr个，那么后者无论拿走1 m1 m个先者只要的数目使和为m+1m+1，那么先手必赢。反之若n=k∗(m+1)n=k∗(m+1)，那么先手无论怎样都会输。

```c++
if (n % (m + 1))  return false;
else  return true;
```

### 2.威佐夫博弈（Wythoff Game）

  有两堆各若干物品，两个人轮流从任意一堆中至少取出一个或者从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜。

  这里的必输局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。从这些必输局势可以发现，每组的第一个是前面没有出现的最小正整数，ak=[k∗(1+5–√)/2], bk=ak+k, k=0,1,2,3...ak=[k∗(1+5)/2], bk=ak+k, k=0,1,2,3...。

  所以，先求出差值，差值*黄金分割比 == 最小值的话后手赢，否者先手赢。

```c++
double r = (sqrt(5) + 1) / 2;
int d = abs(a - b) * r;
if (d != min(a, b))  return true;
else  false;
```

注：如果a,b的值非常大的话，需要高精度来计算这个double类型的r。

### 3.斐波那契博弈（Fibonacci Nim Game）

  一堆石子有n个，两人轮流取，先取者第一次可以去任意多个，但是不能取完，以后每次取的石子数不能超过上次取子数的2倍。取完者胜。

  同样是一个规律：先手胜当且仅当n不是斐波那契数。

```c++
f[0] = f[1] = 1;
for (int i = 0; f[i - 1] < n; i++)
{
    f[i] = f[i - 1] + f[i - 2];
    if (f[i] == n)  return true;
}
return false;
```

### 4.尼姆博弈（Nimm Game）

  有n堆物品，两人轮流取，每次取某堆中不少于1个，最后取完者胜。

  假如有3堆物品(a,b,c) 
 （0，0，0）状态时先手是一个必输局势因为没有东西可取，(0,n,n) 状态时也是必输局势只要后者在另一堆取得物品与前者一样多时那么前者也就是必输局势。慢分析(1,2,3)也是一个必输局势。如果我们将其转化为二进制形式并通过异或运算(^)我们会发现： 
    0001^0010^0011=0000 
通过验证所有的堆数量累^后只要为0就都是必输局势，所以我们就只要记住这个规则：将n堆物品数量全部异或后结果为0先手必败，否则必胜。

```c++
int res = 0;
for (int i = 1; i <= n; i++)
    res ^= arr[i];
if (res)  return true;
else  return false;
```

   但是，实际问题中不可能给出如此标准的博弈模型，对于更加一般的博弈问题，我们该如何求解呢？通过SG函数转换为尼姆博弈。

 

### 5.SG函数

  首先给出一种ICG博弈游戏模型，给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿着有向边进行移动，无法移动者判负。

  **将ICG问题进行转化**：任何一个ICG都可以通过把每个局面看作一个顶点，对每个局面和它的子局面连一条有向边来抽象这个“有向图游戏”。

  于是我们将ICG问题转化为上述这个游戏，再通过寻找这个游戏的一般解法来处理ICG问题。

  首先**定义mex**(minimal excludant)运算，这是定义于一个集合的运算，表示最小的不属于这个集合的最小非负整数。例如mex{0,1,2,4}=3，mex{2,3,4}=0，mex{}=0.

  SG函数（Sprague-Grundy）：对于一个给定的有向无环图，定义关于这个图的每个顶点的SG函数如下：sg(x)=mex{sg(y) | y是x的后继}sg(x)=mex{sg(y) | y是x的后继}

  **SG函数的求法**：

1. 找出必败态
2. 找出当前所有状态的前驱结点
3. 根据定义计算结点SG值
4. 重复上述步骤，直到整棵树建立完成

  按上述步骤建成的树如下：

[<img src="https://img2018.cnblogs.com/blog/1365470/201904/1365470-20190406173738243-2023239617.png" alt="img" style="zoom:33%;" />](https://img2018.cnblogs.com/blog/1365470/201904/1365470-20190406173738243-2023239617.png)

  这颗树有什么意义呢？比如说我们将一个顶点放在根节点上，当前这个点的sg值为0，说明当前这个点是必败态。为什么这么说呢？我们将这个点交替进行移动，先手有两种选择，往右移动，显然后手再移动一步就进入必败态；往左移动，后手会选择往右移动，先手同样进入必败态。

  如何通过SG函数值来解决之前的有向图问题呢？对于n个棋子，设它们对应的顶点的SG函数值分别为{a1,a2,...an}{a1,a2,...an}，再设局面{a1,a2,...an}{a1,a2,...an}时的Nim游戏的必胜策略是把aiai变成kk，那么原游戏的一种必胜策略就是把第ii枚棋子移动到一个SG值为kk的顶点。

  简单来说，我们让每个结点都拥有一个SG值（假设这个值为xx），那么对于任何一个玩家操作（移动到当前结点的某个后继结点）实际上就是把棋子移动到0~x-1的某个结点上，等价的就是从x个物品中取走一个，最多x个！。

  不是是觉得有点不对，单根据mex的定义，可能出现如下情况，移动到比自身SG值大的结点：

[<img src="https://img2018.cnblogs.com/blog/1365470/201904/1365470-20190406180827114-1344789323.png" alt="img" style="zoom: 33%;" />](https://img2018.cnblogs.com/blog/1365470/201904/1365470-20190406180827114-1344789323.png)

  其实这种情况是不存在的，博弈问题中先手不会移动到对自己不利的局面的，在这里也就是不会移动到SG值为4的结点。

  **SG定理**：所以我们可以定义有向图游戏的和。设G1,G2,...GnG1,G2,...Gn为n个“有向图”游戏的和(Sum)，游戏G的移动规则是：任选一个子游戏GiGi并移动上面的棋子。SG定理就是：sg(G)=sg(G1)∧sg(G2)∧....∧sg(Gn)sg(G)=sg(G1)∧sg(G2)∧....∧sg(Gn)。也就是说，游戏的SG函数值就是它的所有子游戏的SG函数值的异或。

  因此，当我们面对n个不同游组成的游戏时，只需要求出每个游戏的SG函数值，把这些SG值都看作Nim的石子堆，然后依照找Nim游戏的必胜策略的方法来找这个游戏的必胜策略。

 

